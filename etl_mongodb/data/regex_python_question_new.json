[
    {
        "QN": "1",
        "type": "mcq",
        "question": "Which module in Python is used for working with regular expressions?",
        "options": {
            "A": "regex",
            "B": "re",
            "C": "pyregex",
            "D": "regexp"
        },
        "answer": "B",
        "explanation": "The 're' module is the standard library module in Python for working with regular expressions."
    },
    {
        "QN": "2",
        "type": "mcq",
        "question": "What does the 're.match()' function do?",
        "options": {
            "A": "Matches a pattern at the end of a string",
            "B": "Matches a pattern at the start of a string",
            "C": "Matches a pattern anywhere in the string",
            "D": "Searches for all occurrences of a pattern in a string"
        },
        "answer": "B",
        "explanation": "The 're.match()' function checks for a match only at the beginning of the string."
    },
    {
        "QN": "3",
        "type": "mcq",
        "question": "Which of the following patterns matches any single character except a newline?",
        "options": {
            "A": "\\d",
            "B": "\\w",
            "C": ".",
            "D": "\\s"
        },
        "answer": "C",
        "explanation": "The dot (.) in regular expressions matches any single character except a newline."
    },
    {
        "QN": "4",
        "type": "mcq",
        "question": "What does the '\\d' pattern match in regular expressions?",
        "options": {
            "A": "Any digit (0-9)",
            "B": "Any non-digit character",
            "C": "Any whitespace character",
            "D": "Any word character (a-z, A-Z, 0-9, _)"
        },
        "answer": "A",
        "explanation": "The '\\d' pattern matches any digit from 0 to 9."
    },
    {
        "QN": "5",
        "type": "mcq",
        "question": "Which function is used to search for a pattern anywhere in a string?",
        "options": {
            "A": "re.match()",
            "B": "re.findall()",
            "C": "re.search()",
            "D": "re.split()"
        },
        "answer": "C",
        "explanation": "The 're.search()' function searches for a pattern anywhere in the string, unlike 're.match()' which only checks the beginning."
    },
    {
        "QN": "6",
        "type": "mcq",
        "question": "What does the 're.findall()' function return?",
        "options": {
            "A": "A list of all matches",
            "B": "The first match found",
            "C": "A match object",
            "D": "The number of matches"
        },
        "answer": "A",
        "explanation": "The 're.findall()' function returns a list of all non-overlapping matches of the pattern in the string."
    },
    {
        "QN": "7",
        "type": "mcq",
        "question": "Which of the following patterns matches one or more occurrences of the preceding element?",
        "options": {
            "A": "*",
            "B": "+",
            "C": "?",
            "D": "{}"
        },
        "answer": "B",
        "explanation": "The '+' quantifier matches one or more occurrences of the preceding element."
    },
    {
        "QN": "8",
        "type": "mcq",
        "question": "What does the 're.sub()' function do?",
        "options": {
            "A": "Searches for a pattern in a string",
            "B": "Replaces occurrences of a pattern in a string",
            "C": "Splits a string by a pattern",
            "D": "Finds all matches of a pattern in a string"
        },
        "answer": "B",
        "explanation": "The 're.sub()' function replaces all occurrences of a pattern in a string with a specified replacement."
    },
    {
        "QN": "9",
        "type": "mcq",
        "question": "Which of the following patterns matches zero or more occurrences of the preceding element?",
        "options": {
            "A": "*",
            "B": "+",
            "C": "?",
            "D": "{}"
        },
        "answer": "A",
        "explanation": "The '*' quantifier matches zero or more occurrences of the preceding element."
    },
    {
        "QN": "10",
        "type": "mcq",
        "question": "What does the '\\w' pattern match in regular expressions?",
        "options": {
            "A": "Any digit (0-9)",
            "B": "Any non-digit character",
            "C": "Any whitespace character",
            "D": "Any word character (a-z, A-Z, 0-9, _)"
        },
        "answer": "D",
        "explanation": "The '\\w' pattern matches any word character, which includes letters (a-z, A-Z), digits (0-9), and underscores (_)."
    },
    {
        "QN": "11",
        "type": "mcq",
        "question": "Which of the following patterns matches exactly three digits?",
        "options": {
            "A": "\\d{3}",
            "B": "\\d{1,3}",
            "C": "\\d+",
            "D": "\\d*"
        },
        "answer": "A",
        "explanation": "The pattern '\\d{3}' matches exactly three digits."
    },
    {
        "QN": "12",
        "type": "mcq",
        "question": "What does the 're.split()' function do?",
        "options": {
            "A": "Searches for a pattern in a string",
            "B": "Replaces occurrences of a pattern in a string",
            "C": "Splits a string by a pattern",
            "D": "Finds all matches of a pattern in a string"
        },
        "answer": "C",
        "explanation": "The 're.split()' function splits a string by the occurrences of a specified pattern."
    },
    {
        "QN": "13",
        "type": "mcq",
        "question": "Which of the following patterns matches any whitespace character?",
        "options": {
            "A": "\\d",
            "B": "\\w",
            "C": "\\s",
            "D": "."
        },
        "answer": "C",
        "explanation": "The '\\s' pattern matches any whitespace character, including spaces, tabs, and newlines."
    },
    {
        "QN": "14",
        "type": "mcq",
        "question": "What does the '?' quantifier do in regular expressions?",
        "options": {
            "A": "Matches zero or more occurrences of the preceding element",
            "B": "Matches one or more occurrences of the preceding element",
            "C": "Matches zero or one occurrence of the preceding element",
            "D": "Matches exactly one occurrence of the preceding element"
        },
        "answer": "C",
        "explanation": "The '?' quantifier matches zero or one occurrence of the preceding element."
    },
    {
        "QN": "15",
        "type": "mcq",
        "question": "Which of the following patterns matches a word boundary?",
        "options": {
            "A": "\\b",
            "B": "\\B",
            "C": "\\w",
            "D": "\\W"
        },
        "answer": "A",
        "explanation": "The '\\b' pattern matches a word boundary, which is the position between a word character and a non-word character."
    },
    {
        "QN": "16",
        "type": "mcq",
        "question": "What does the 're.compile()' function do?",
        "options": {
            "A": "Searches for a pattern in a string",
            "B": "Compiles a regular expression pattern into a regex object",
            "C": "Replaces occurrences of a pattern in a string",
            "D": "Splits a string by a pattern"
        },
        "answer": "B",
        "explanation": "The 're.compile()' function compiles a regular expression pattern into a regex object, which can be used for matching and searching."
    },
    {
        "QN": "17",
        "type": "mcq",
        "question": "Which of the following patterns matches any non-whitespace character?",
        "options": {
            "A": "\\d",
            "B": "\\w",
            "C": "\\S",
            "D": "."
        },
        "answer": "C",
        "explanation": "The '\\S' pattern matches any non-whitespace character."
    },
    {
        "QN": "18",
        "type": "mcq",
        "question": "What does the 're.IGNORECASE' flag do?",
        "options": {
            "A": "Makes the pattern case-sensitive",
            "B": "Ignores whitespace in the pattern",
            "C": "Makes the pattern case-insensitive",
            "D": "Ignores special characters in the pattern"
        },
        "answer": "C",
        "explanation": "The 're.IGNORECASE' flag makes the pattern case-insensitive, allowing matches regardless of letter case."
    },
    {
        "QN": "19",
        "type": "mcq",
        "question": "Which of the following patterns matches any non-digit character?",
        "options": {
            "A": "\\d",
            "B": "\\D",
            "C": "\\w",
            "D": "\\W"
        },
        "answer": "B",
        "explanation": "The '\\D' pattern matches any non-digit character."
    },
    {
        "QN": "20",
        "type": "mcq",
        "question": "What does the 're.MULTILINE' flag do?",
        "options": {
            "A": "Makes the '^' and '$' anchors match the start and end of each line",
            "B": "Makes the pattern case-insensitive",
            "C": "Ignores whitespace in the pattern",
            "D": "Allows comments in the pattern"
        },
        "answer": "A",
        "explanation": "The 're.MULTILINE' flag makes the '^' and '$' anchors match the start and end of each line, rather than the start and end of the entire string."
    },
    {
        "QN": "21",
        "type": "mcq",
        "question": "Which of the following patterns matches any non-word character?",
        "options": {
            "A": "\\d",
            "B": "\\D",
            "C": "\\w",
            "D": "\\W"
        },
        "answer": "D",
        "explanation": "The '\\W' pattern matches any non-word character, which is any character that is not a letter, digit, or underscore."
    },
    {
        "QN": "22",
        "type": "mcq",
        "question": "What does the 're.DOTALL' flag do?",
        "options": {
            "A": "Makes the '.' pattern match newline characters",
            "B": "Makes the pattern case-insensitive",
            "C": "Ignores whitespace in the pattern",
            "D": "Allows comments in the pattern"
        },
        "answer": "A",
        "explanation": "The 're.DOTALL' flag makes the '.' pattern match newline characters, allowing it to match any character including newlines."
    },
    {
        "QN": "23",
        "type": "mcq",
        "question": "Which of the following patterns matches the start of a string?",
        "options": {
            "A": "^",
            "B": "$",
            "C": "\\b",
            "D": "\\B"
        },
        "answer": "A",
        "explanation": "The '^' pattern matches the start of a string."
    },
    {
        "QN": "24",
        "type": "mcq",
        "question": "What does the 're.VERBOSE' flag do?",
        "options": {
            "A": "Makes the pattern case-insensitive",
            "B": "Ignores whitespace in the pattern",
            "C": "Allows comments and whitespace in the pattern for better readability",
            "D": "Makes the '.' pattern match newline characters"
        },
        "answer": "C",
        "explanation": "The 're.VERBOSE' flag allows you to write more readable regular expressions by ignoring whitespace and allowing comments within the pattern."
    },
    {
        "QN": "25",
        "type": "mcq",
        "question": "Which of the following patterns matches the end of a string?",
        "options": {
            "A": "^",
            "B": "$",
            "C": "\\b",
            "D": "\\B"
        },
        "answer": "B",
        "explanation": "The '$' pattern matches the end of a string."
    },
    {
        "QN": "26",
        "type": "mcq",
        "question": "What does the 're.fullmatch()' function do?",
        "options": {
            "A": "Matches a pattern at the start of a string",
            "B": "Matches a pattern anywhere in the string",
            "C": "Matches the entire string against the pattern",
            "D": "Searches for all occurrences of a pattern in a string"
        },
        "answer": "C",
        "explanation": "The 're.fullmatch()' function matches the entire string against the pattern, ensuring that the whole string conforms to the pattern."
    },
    {
        "QN": "27",
        "type": "mcq",
        "question": "Which of the following patterns matches a tab character?",
        "options": {
            "A": "\\t",
            "B": "\\n",
            "C": "\\r",
            "D": "\\f"
        },
        "answer": "A",
        "explanation": "The '\\t' pattern matches a tab character."
    },
    {
        "QN": "28",
        "type": "mcq",
        "question": "What does the 're.escape()' function do?",
        "options": {
            "A": "Escapes all special characters in a string",
            "B": "Searches for a pattern in a string",
            "C": "Replaces occurrences of a pattern in a string",
            "D": "Splits a string by a pattern"
        },
        "answer": "A",
        "explanation": "The 're.escape()' function escapes all special characters in a string, making it safe to use as a literal pattern in regular expressions."
    },
    {
        "QN": "29",
        "type": "mcq",
        "question": "Which of the following patterns matches a newline character?",
        "options": {
            "A": "\\t",
            "B": "\\n",
            "C": "\\r",
            "D": "\\f"
        },
        "answer": "B",
        "explanation": "The '\\n' pattern matches a newline character."
    },
    {
        "QN": "30",
        "type": "mcq",
        "question": "What does the 're.finditer()' function return?",
        "options": {
            "A": "A list of all matches",
            "B": "An iterator yielding match objects",
            "C": "The first match found",
            "D": "The number of matches"
        },
        "answer": "B",
        "explanation": "The 're.finditer()' function returns an iterator yielding match objects for all non-overlapping matches of the pattern in the string."
    },
    {
        "QN": "31",
        "type": "mcq",
        "question": "Which of the following patterns matches a carriage return character?",
        "options": {
            "A": "\\t",
            "B": "\\n",
            "C": "\\r",
            "D": "\\f"
        },
        "answer": "C",
        "explanation": "The '\\r' pattern matches a carriage return character."
    },
    {
        "QN": "32",
        "type": "mcq",
        "question": "What does the 're.purge()' function do?",
        "options": {
            "A": "Clears the regular expression cache",
            "B": "Searches for a pattern in a string",
            "C": "Replaces occurrences of a pattern in a string",
            "D": "Splits a string by a pattern"
        },
        "answer": "A",
        "explanation": "The 're.purge()' function clears the regular expression cache, which can be useful to free up memory or reset cached patterns."
    },
    {
        "QN": "33",
        "type": "mcq",
        "question": "Which of the following patterns matches a form feed character?",
        "options": {
            "A": "\\t",
            "B": "\\n",
            "C": "\\r",
            "D": "\\f"
        },
        "answer": "D",
        "explanation": "The '\\f' pattern matches a form feed character."
    },
    {
        "QN": "34",
        "type": "mcq",
        "question": "What does the 're.template()' function do?",
        "options": {
            "A": "Compiles a regular expression pattern into a regex object",
            "B": "Escapes all special characters in a string",
            "C": "Creates a template for string substitution",
            "D": "Searches for a pattern in a string"
        },
        "answer": "C",
        "explanation": "The 're.template()' function creates a template for string substitution, allowing you to define a pattern with placeholders that can be replaced with actual values."
    },
    {
        "QN": "35",
        "type": "mcq",
        "question": "Which of the following patterns matches a vertical tab character?",
        "options": {
            "A": "\\t",
            "B": "\\n",
            "C": "\\v",
            "D": "\\f"
        },
        "answer": "C",
        "explanation": "The '\\v' pattern matches a vertical tab character."
    },
    {
        "QN": "36",
        "type": "mcq",
        "question": "What does the 're.subn()' function return?",
        "options": {
            "A": "A list of all matches",
            "B": "A tuple containing the new string and the number of substitutions made",
            "C": "The first match found",
            "D": "The number of matches"
        },
        "answer": "B",
        "explanation": "The 're.subn()' function returns a tuple containing the new string and the number of substitutions made."
    },
    {
        "QN": "37",
        "type": "mcq",
        "question": "Which of the following patterns matches a backspace character?",
        "options": {
            "A": "\\t",
            "B": "\\n",
            "C": "\\b",
            "D": "\\f"
        },
        "answer": "C",
        "explanation": "The '\\b' pattern matches a backspace character when used inside a character class."
    },
    {
        "QN": "38",
        "type": "mcq",
        "question": "What does the 're.Scanner()' function do?",
        "options": {
            "A": "Scans a string for patterns and returns a list of tokens",
            "B": "Searches for a pattern in a string",
            "C": "Replaces occurrences of a pattern in a string",
            "D": "Splits a string by a pattern"
        },
        "answer": "A",
        "explanation": "The 're.Scanner()' function scans a string for patterns and returns a list of tokens, making it useful for lexical analysis."
    },
    {
        "QN": "39",
        "type": "mcq",
        "question": "Which of the following patterns matches a hexadecimal digit?",
        "options": {
            "A": "\\d",
            "B": "\\w",
            "C": "\\x",
            "D": "\\h"
        },
        "answer": "C",
        "explanation": "The '\\x' pattern matches a hexadecimal digit, which includes digits 0-9 and letters A-F (case-insensitive)."
    },
    {
        "QN": "40",
        "type": "mcq",
        "question": "What does the 're.LOCALE' flag do?",
        "options": {
            "A": "Makes the pattern case-insensitive",
            "B": "Makes \\w, \\W, \\b, \\B dependent on the current locale",
            "C": "Ignores whitespace in the pattern",
            "D": "Allows comments in the pattern"
        },
        "answer": "B",
        "explanation": "The 're.LOCALE' flag makes the patterns \\w, \\W, \\b, and \\B dependent on the current locale, which affects how they match characters."
    },
    {
        "QN": "41",
        "type": "mcq",
        "question": "Which of the following patterns matches an octal digit?",
        "options": {
            "A": "\\d",
            "B": "\\o",
            "C": "\\O",
            "D": "\\0"
        },
        "answer": "B",
        "explanation": "The '\\o' pattern matches an octal digit, which includes digits 0-7."
    },
    {
        "QN": "42",
        "type": "mcq",
        "question": "What does the 're.ASCII' flag do?",
        "options": {
            "A": "Makes the pattern case-insensitive",
            "B": "Makes \\w, \\W, \\b, \\B match only ASCII characters",
            "C": "Ignores whitespace in the pattern",
            "D": "Allows comments in the pattern"
        },
        "answer": "B",
        "explanation": "The 're.ASCII' flag makes the patterns \\w, \\W, \\b, and \\B match only ASCII characters, rather than Unicode characters."
    },
    {
        "QN": "43",
        "type": "mcq",
        "question": "Which of the following patterns matches a Unicode word character?",
        "options": {
            "A": "\\d",
            "B": "\\w",
            "C": "\\W",
            "D": "\\u"
        },
        "answer": "B",
        "explanation": "The '\\w' pattern matches a Unicode word character, which includes letters, digits, and underscores from any language."
    },
    {
        "QN": "44",
        "type": "mcq",
        "question": "What does the 're.DEBUG' flag do?",
        "options": {
            "A": "Prints debugging information about the compiled pattern",
            "B": "Makes the pattern case-insensitive",
            "C": "Ignores whitespace in the pattern",
            "D": "Allows comments in the pattern"
        },
        "answer": "A",
        "explanation": "The 're.DEBUG' flag prints debugging information about the compiled pattern, which can be useful for understanding how the pattern is being interpreted."
    },
    {
        "QN": "45",
        "type": "mcq",
        "question": "Which of the following patterns matches a non-Unicode word character?",
        "options": {
            "A": "\\d",
            "B": "\\w",
            "C": "\\W",
            "D": "\\u"
        },
        "answer": "C",
        "explanation": "The '\\W' pattern matches a non-Unicode word character, which is any character that is not a letter, digit, or underscore."
    },
    {
        "QN": "46",
        "type": "mcq",
        "question": "What does the 're.A' flag do?",
        "options": {
            "A": "Makes the pattern case-insensitive",
            "B": "Makes \\w, \\W, \\b, \\B match only ASCII characters",
            "C": "Ignores whitespace in the pattern",
            "D": "Allows comments in the pattern"
        },
        "answer": "B",
        "explanation": "The 're.A' flag is an alias for 're.ASCII', making \\w, \\W, \\b, and \\B match only ASCII characters."
    },
    {
        "QN": "47",
        "type": "mcq",
        "question": "Which of the following patterns matches a Unicode digit?",
        "options": {
            "A": "\\d",
            "B": "\\D",
            "C": "\\w",
            "D": "\\W"
        },
        "answer": "A",
        "explanation": "The '\\d' pattern matches a Unicode digit, which includes digits from any language."
    },
    {
        "QN": "48",
        "type": "mcq",
        "question": "What does the 're.I' flag do?",
        "options": {
            "A": "Makes the pattern case-insensitive",
            "B": "Makes \\w, \\W, \\b, \\B match only ASCII characters",
            "C": "Ignores whitespace in the pattern",
            "D": "Allows comments in the pattern"
        },
        "answer": "A",
        "explanation": "The 're.I' flag is an alias for 're.IGNORECASE', making the pattern case-insensitive."
    },
    {
        "QN": "49",
        "type": "mcq",
        "question": "Which of the following patterns matches a non-Unicode digit?",
        "options": {
            "A": "\\d",
            "B": "\\D",
            "C": "\\w",
            "D": "\\W"
        },
        "answer": "B",
        "explanation": "The '\\D' pattern matches a non-Unicode digit, which is any character that is not a digit."
    },
    {
        "QN": "50",
        "type": "mcq",
        "question": "What does the 're.M' flag do?",
        "options": {
            "A": "Makes the '^' and '$' anchors match the start and end of each line",
            "B": "Makes the pattern case-insensitive",
            "C": "Ignores whitespace in the pattern",
            "D": "Allows comments in the pattern"
        },
        "answer": "A",
        "explanation": "The 're.M' flag is an alias for 're.MULTILINE', making the '^' and '$' anchors match the start and end of each line."
    },
    {
        "QN": "51",
        "type": "mcq",
        "question": "Which of the following patterns matches a Unicode whitespace character?",
        "options": {
            "A": "\\d",
            "B": "\\s",
            "C": "\\w",
            "D": "\\W"
        },
        "answer": "B",
        "explanation": "The '\\s' pattern matches a Unicode whitespace character, which includes spaces, tabs, newlines, and other whitespace characters from any language."
    },
    {
        "QN": "52",
        "type": "mcq",
        "question": "What does the 're.S' flag do?",
        "options": {
            "A": "Makes the '.' pattern match newline characters",
            "B": "Makes the pattern case-insensitive",
            "C": "Ignores whitespace in the pattern",
            "D": "Allows comments in the pattern"
        },
        "answer": "A",
        "explanation": "The 're.S' flag is an alias for 're.DOTALL', making the '.' pattern match newline characters."
    },
    {
        "QN": "53",
        "type": "mcq",
        "question": "Which of the following patterns matches a non-Unicode whitespace character?",
        "options": {
            "A": "\\d",
            "B": "\\s",
            "C": "\\S",
            "D": "\\W"
        },
        "answer": "C",
        "explanation": "The '\\S' pattern matches a non-Unicode whitespace character, which is any character that is not a whitespace character."
    },
    {
        "QN": "54",
        "type": "mcq",
        "question": "What does the 're.X' flag do?",
        "options": {
            "A": "Makes the pattern case-insensitive",
            "B": "Ignores whitespace in the pattern",
            "C": "Allows comments and whitespace in the pattern for better readability",
            "D": "Makes the '.' pattern match newline characters"
        },
        "answer": "C",
        "explanation": "The 're.X' flag is an alias for 're.VERBOSE', allowing comments and whitespace in the pattern for better readability."
    },
    {
        "QN": "55",
        "type": "mcq",
        "question": "Which of the following patterns matches a Unicode newline character?",
        "options": {
            "A": "\\d",
            "B": "\\n",
            "C": "\\r",
            "D": "\\u"
        },
        "answer": "B",
        "explanation": "The '\\n' pattern matches a Unicode newline character."
    },
    {
        "QN": "56",
        "type": "mcq",
        "question": "What does the 're.L' flag do?",
        "options": {
            "A": "Makes the pattern case-insensitive",
            "B": "Makes \\w, \\W, \\b, \\B dependent on the current locale",
            "C": "Ignores whitespace in the pattern",
            "D": "Allows comments in the pattern"
        },
        "answer": "B",
        "explanation": "The 're.L' flag is an alias for 're.LOCALE', making \\w, \\W, \\b, and \\B dependent on the current locale."
    },
    {
        "QN": "57",
        "type": "mcq",
        "question": "Which of the following patterns matches a Unicode tab character?",
        "options": {
            "A": "\\t",
            "B": "\\n",
            "C": "\\r",
            "D": "\\u"
        },
        "answer": "A",
        "explanation": "The '\\t' pattern matches a Unicode tab character."
    },
    {
        "QN": "58",
        "type": "mcq",
        "question": "What does the 're.U' flag do?",
        "options": {
            "A": "Makes the pattern case-insensitive",
            "B": "Makes \\w, \\W, \\b, \\B match Unicode characters",
            "C": "Ignores whitespace in the pattern",
            "D": "Allows comments in the pattern"
        },
        "answer": "B",
        "explanation": "The 're.U' flag is an alias for 're.UNICODE', making \\w, \\W, \\b, and \\B match Unicode characters."
    },
    {
        "QN": "59",
        "type": "mcq",
        "question": "Which of the following patterns matches a Unicode carriage return character?",
        "options": {
            "A": "\\t",
            "B": "\\n",
            "C": "\\r",
            "D": "\\u"
        },
        "answer": "C",
        "explanation": "The '\\r' pattern matches a Unicode carriage return character."
    },
    {
        "QN": "60",
        "type": "mcq",
        "question": "What does the 're.UNICODE' flag do?",
        "options": {
            "A": "Makes the pattern case-insensitive",
            "B": "Makes \\w, \\W, \\b, \\B match Unicode characters",
            "C": "Ignores whitespace in the pattern",
            "D": "Allows comments in the pattern"
        },
        "answer": "B",
        "explanation": "The 're.UNICODE' flag makes \\w, \\W, \\b, and \\B match Unicode characters, which is the default behavior in Python 3."
    },
    {
        "QN": "61",
        "type": "mcq",
        "question": "Which of the following patterns matches a Unicode form feed character?",
        "options": {
            "A": "\\t",
            "B": "\\n",
            "C": "\\r",
            "D": "\\f"
        },
        "answer": "D",
        "explanation": "The '\\f' pattern matches a Unicode form feed character."
    },
    {
        "QN": "62",
        "type": "mcq",
        "question": "Which of the following patterns matches a Unicode vertical tab character?",
        "options": {
            "A": "\\t",
            "B": "\\n",
            "C": "\\v",
            "D": "\\f"
        },
        "answer": "C",
        "explanation": "The '\\v' pattern matches a Unicode vertical tab character."
    },
    {
        "QN": "63",
        "type": "mcq",
        "question": "Which of the following patterns matches a Unicode backspace character?",
        "options": {
            "A": "\\t",
            "B": "\\n",
            "C": "\\b",
            "D": "\\f"
        },
        "answer": "C",
        "explanation": "The '\\b' pattern matches a Unicode backspace character when used inside a character class."
    },
    {
        "QN": "64",
        "type": "mcq",
        "question": "Which of the following patterns matches a Unicode hexadecimal digit?",
        "options": {
            "A": "\\d",
            "B": "\\w",
            "C": "\\x",
            "D": "\\h"
        },
        "answer": "C",
        "explanation": "The '\\x' pattern matches a Unicode hexadecimal digit, which includes digits 0-9 and letters A-F (case-insensitive)."
    },
    {
        "QN": "65",
        "type": "mcq",
        "question": "Which of the following patterns matches a Unicode octal digit?",
        "options": {
            "A": "\\d",
            "B": "\\o",
            "C": "\\O",
            "D": "\\0"
        },
        "answer": "B",
        "explanation": "The '\\o' pattern matches a Unicode octal digit, which includes digits 0-7."
    },
    {
        "QN": "66",
        "type": "mcq",
        "question": "Which of the following patterns matches a Unicode word boundary?",
        "options": {
            "A": "\\b",
            "B": "\\B",
            "C": "\\w",
            "D": "\\W"
        },
        "answer": "A",
        "explanation": "The '\\b' pattern matches a Unicode word boundary, which is the position between a word character and a non-word character."
    },
    {
        "QN": "67",
        "type": "mcq",
        "question": "Which of the following patterns matches a Unicode non-word boundary?",
        "options": {
            "A": "\\b",
            "B": "\\B",
            "C": "\\w",
            "D": "\\W"
        },
        "answer": "B",
        "explanation": "The '\\B' pattern matches a Unicode non-word boundary, which is the position between two word characters or two non-word characters."
    },
    {
        "QN": "68",
        "type": "mcq",
        "question": "Which of the following patterns matches a Unicode non-word character?",
        "options": {
            "A": "\\d",
            "B": "\\w",
            "C": "\\W",
            "D": "\\u"
        },
        "answer": "C",
        "explanation": "The '\\W' pattern matches a Unicode non-word character, which is any character that is not a letter, digit, or underscore."
    },
    {
        "QN": "69",
        "type": "mcq",
        "question": "Which of the following patterns matches a Unicode non-digit character?",
        "options": {
            "A": "\\d",
            "B": "\\D",
            "C": "\\w",
            "D": "\\W"
        },
        "answer": "B",
        "explanation": "The '\\D' pattern matches a Unicode non-digit character, which is any character that is not a digit."
    },
    {
        "QN": "70",
        "type": "mcq",
        "question": "Which of the following patterns matches a Unicode non-whitespace character?",
        "options": {
            "A": "\\d",
            "B": "\\s",
            "C": "\\S",
            "D": "\\W"
        },
        "answer": "C",
        "explanation": "The '\\S' pattern matches a Unicode non-whitespace character, which is any character that is not a whitespace character."
    },
    {
        "QN": "71",
        "type": "mcq",
        "question": "What is the purpose of the 're' module in Python?",
        "options": {
            "A": "For handling exceptions",
            "B": "For working with regular expressions",
            "C": "For database operations",
            "D": "For network programming"
        },
        "answer": "B",
        "explanation": "The 're' module in Python provides support for regular expressions, which are used for pattern matching in strings."
    },
    {
        "QN": "72",
        "type": "mcq",
        "question": "What does the '^' symbol represent in a regular expression?",
        "options": {
            "A": "End of a string",
            "B": "Start of a string",
            "C": "Any character",
            "D": "Digit"
        },
        "answer": "B",
        "explanation": "The '^' symbol in a regular expression represents the start of a string."
    },
    {
        "QN": "73",
        "type": "mcq",
        "question": "Which function is used to search for the first occurrence of a pattern in a string?",
        "options": {
            "A": "re.match()",
            "B": "re.search()",
            "C": "re.findall()",
            "D": "re.sub()"
        },
        "answer": "B",
        "explanation": "The 're.search()' function is used to search for the first occurrence of a pattern in a string."
    },
    {
        "QN": "74",
        "type": "mcq",
        "question": "What does the '\\d' character class represent in a regular expression?",
        "options": {
            "A": "Any whitespace character",
            "B": "Any digit",
            "C": "Any letter",
            "D": "Any special character"
        },
        "answer": "B",
        "explanation": "The '\\d' character class in a regular expression represents any digit (equivalent to [0-9])."
    },
    {
        "QN": "75",
        "type": "mcq",
        "question": "What is the purpose of the 're.IGNORECASE' flag?",
        "options": {
            "A": "To make the pattern case-sensitive",
            "B": "To make the pattern case-insensitive",
            "C": "To ignore whitespace",
            "D": "To ignore special characters"
        },
        "answer": "B",
        "explanation": "The 're.IGNORECASE' flag makes the pattern case-insensitive, so it matches both lowercase and uppercase characters."
    },
    {
        "QN": "76",
        "type": "mcq",
        "question": "What does the 're.findall()' function return?",
        "options": {
            "A": "A single match object",
            "B": "A list of all matches",
            "C": "A boolean indicating if a match was found",
            "D": "The original string"
        },
        "answer": "B",
        "explanation": "The 're.findall()' function returns a list of all matches in the string."
    },
    {
        "QN": "77",
        "type": "mcq",
        "question": "What is the purpose of the 're.sub()' function?",
        "options": {
            "A": "To search for a pattern",
            "B": "To replace occurrences of a pattern",
            "C": "To split a string",
            "D": "To join strings"
        },
        "answer": "B",
        "explanation": "The 're.sub()' function is used to replace occurrences of a pattern in a string."
    },
    {
        "QN": "78",
        "type": "mcq",
        "question": "What does the 're.compile()' function do?",
        "options": {
            "A": "It compiles a regular expression pattern into a regular expression object",
            "B": "It searches for a pattern in a string",
            "C": "It replaces occurrences of a pattern",
            "D": "It splits a string"
        },
        "answer": "A",
        "explanation": "The 're.compile()' function compiles a regular expression pattern into a regular expression object, which can be used for matching using its 'match()', 'search()', and other methods."
    },
    {
        "QN": "79",
        "type": "mcq",
        "question": "What does the 're.split()' function do?",
        "options": {
            "A": "It joins strings using a pattern",
            "B": "It splits a string using a pattern",
            "C": "It searches for a pattern in a string",
            "D": "It replaces occurrences of a pattern"
        },
        "answer": "B",
        "explanation": "The 're.split()' function splits a string into substrings using a regular expression pattern as the separator."
    },
    {
        "QN": "80",
        "type": "mcq",
        "question": "What is the purpose of the 're.escape()' function?",
        "options": {
            "A": "To unescape special characters in a string",
            "B": "To escape special characters in a string",
            "C": "To compile a regular expression pattern",
            "D": "To search for a pattern in a string"
        },
        "answer": "B",
        "explanation": "The 're.escape()' function escapes all special characters in a string so that it can be used as a literal string in a regular expression."
    },
    {
        "QN": "81",
        "type": "mcq",
        "question": "What does the 're.MULTILINE' flag do?",
        "options": {
            "A": "Makes the pattern case-insensitive",
            "B": "Makes the '^' and '$' anchors match the start and end of each line",
            "C": "Makes the '.' special character match any character including newline",
            "D": "Ignores whitespace characters"
        },
        "answer": "B",
        "explanation": "The 're.MULTILINE' flag makes the '^' and '$' anchors match the start and end of each line in a multiline string, not just the start and end of the entire string."
    },
    {
        "QN": "82",
        "type": "mcq",
        "question": "What does the 're.DOTALL' flag do?",
        "options": {
            "A": "Makes the '.' special character match any character except newline",
            "B": "Makes the '.' special character match any character including newline",
            "C": "Makes the pattern case-insensitive",
            "D": "Ignores whitespace characters"
        },
        "answer": "B",
        "explanation": "The 're.DOTALL' flag makes the '.' special character match any character, including newline characters."
    },
    {
        "QN": "83",
        "type": "mcq",
        "question": "What is the purpose of non-capturing groups in regular expressions?",
        "options": {
            "A": "To capture groups for later reference",
            "B": "To group parts of a pattern without capturing them",
            "C": "To ignore parts of a pattern",
            "D": "To make the pattern case-insensitive"
        },
        "answer": "B",
        "explanation": "Non-capturing groups, denoted by '(?:pattern)', are used to group parts of a pattern without capturing them for later reference."
    },
    {
        "QN": "84",
        "type": "mcq",
        "question": "What does the '(?=pattern)' syntax represent in regular expressions?",
        "options": {
            "A": "Negative lookahead assertion",
            "B": "Positive lookahead assertion",
            "C": "Negative lookbehind assertion",
            "D": "Positive lookbehind assertion"
        },
        "answer": "B",
        "explanation": "The '(?=pattern)' syntax represents a positive lookahead assertion, which checks if the pattern matches without including it in the match."
    },
    {
        "QN": "85",
        "type": "mcq",
        "question": "What does the '(?<=pattern)' syntax represent in regular expressions?",
        "options": {
            "A": "Negative lookahead assertion",
            "B": "Positive lookahead assertion",
            "C": "Negative lookbehind assertion",
            "D": "Positive lookbehind assertion"
        },
        "answer": "D",
        "explanation": "The '(?<=pattern)' syntax represents a positive lookbehind assertion, which checks if the pattern matches before the current position without including it in the match."
    },
    {
        "QN": "86",
        "type": "mcq",
        "question": "How can you validate an email address using regular expressions in Python?",
        "options": {
            "A": "Using the pattern '^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$'",
            "B": "Using the pattern '^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-]$'",
            "C": "Using the pattern '^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9]$'",
            "D": "Using the pattern '^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]$'"
        },
        "answer": "A",
        "explanation": "The pattern '^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$' is commonly used to validate email addresses, allowing for most common email formats."
    },
    {
        "QN": "87",
        "type": "mcq",
        "question": "What is the purpose of the '(?<!pattern)' syntax in regular expressions?",
        "options": {
            "A": "Negative lookahead assertion",
            "B": "Positive lookahead assertion",
            "C": "Negative lookbehind assertion",
            "D": "Positive lookbehind assertion"
        },
        "answer": "C",
        "explanation": "The '(?<!pattern)' syntax represents a negative lookbehind assertion, which checks if the pattern does not match before the current position."
    },
    {
        "QN": "88",
        "type": "mcq",
        "question": "What does the '(?<!pattern)' syntax represent in regular expressions?",
        "options": {
            "A": "Negative lookahead assertion",
            "B": "Positive lookahead assertion",
            "C": "Negative lookbehind assertion",
            "D": "Positive lookbehind assertion"
        },
        "answer": "C",
        "explanation": "The '(?<!pattern)' syntax represents a negative lookbehind assertion, which checks if the pattern does not match before the current position."
    },
    {
        "QN": "89",
        "type": "mcq",
        "question": "What does the '(?!pattern)' syntax represent in regular expressions?",
        "options": {
            "A": "Negative lookahead assertion",
            "B": "Positive lookahead assertion",
            "C": "Negative lookbehind assertion",
            "D": "Positive lookbehind assertion"
        },
        "answer": "A",
        "explanation": "The '(?!pattern)' syntax represents a negative lookahead assertion, which checks if the pattern does not match after the current position."
    },
    {
        "QN": "90",
        "type": "mcq",
        "question": "How can you match a string that contains at least one digit using regular expressions?",
        "options": {
            "A": "Using the pattern '.*\\d.*'",
            "B": "Using the pattern '\\d+'",
            "C": "Using the pattern '\\d*'",
            "D": "Using the pattern '\\D+'"
        },
        "answer": "A",
        "explanation": "The pattern '.*\\d.*' matches any string that contains at least one digit ('\\d'). The '.*' before and after '\\d' ensures that the string can contain characters before and after the digit."
    },
    {
        "QN": "91",
        "type": "mcq",
        "question": "What does the '\\b' special sequence represent in regular expressions?",
        "options": {
            "A": "Word boundary",
            "B": "Non-word boundary",
            "C": "Start of a string",
            "D": "End of a string"
        },
        "answer": "A",
        "explanation": "The '\\b' special sequence represents a word boundary, which is the position where a word character is not followed or preceded by another word character."
    },
    {
        "QN": "92",
        "type": "mcq",
        "question": "How can you match a string that starts with 'abc' using regular expressions?",
        "options": {
            "A": "Using the pattern '^abc.*'",
            "B": "Using the pattern 'abc.*'",
            "C": "Using the pattern '.*abc'",
            "D": "Using the pattern 'abc$'"
        },
        "answer": "A",
        "explanation": "The pattern '^abc.*' matches any string that starts with 'abc'. The '^' symbol ensures the match is at the start of the string."
    },
    {
        "QN": "93",
        "type": "mcq",
        "question": "What does the '\\B' special sequence represent in regular expressions?",
        "options": {
            "A": "Word boundary",
            "B": "Non-word boundary",
            "C": "Start of a string",
            "D": "End of a string"
        },
        "answer": "B",
        "explanation": "The '\\B' special sequence represents a non-word boundary, which is the position where a word character is followed or preceded by another word character."
    },
    {
        "QN": "94",
        "type": "mcq",
        "question": "How can you match a string that ends with 'xyz' using regular expressions?",
        "options": {
            "A": "Using the pattern '^.*xyz'",
            "B": "Using the pattern '.*xyz$'",
            "C": "Using the pattern 'xyz.*'",
            "D": "Using the pattern '^xyz'"
        },
        "answer": "B",
        "explanation": "The pattern '.*xyz$' matches any string that ends with 'xyz'. The '$' symbol ensures the match is at the end of the string."
    },
    {
        "QN": "95",
        "type": "mcq",
        "question": "What does the '{n, m}' syntax represent in regular expressions?",
        "options": {
            "A": "Matches the preceding element at least n times and at most m times",
            "B": "Matches the preceding element exactly n times",
            "C": "Matches the preceding element at least n times",
            "D": "Matches the preceding element at most m times"
        },
        "answer": "A",
        "explanation": "The '{n, m}' syntax represents a quantifier that matches the preceding element at least n times and at most m times."
    },
    {
        "QN": "96",
        "type": "mcq",
        "question": "How can you validate a URL using regular expressions in Python?",
        "options": {
            "A": "Using the pattern '^https?://[^\\s]+'",
            "B": "Using the pattern '^https?://[a-zA-Z0-9-\\.]+\\.[a-zA-Z]{2,}(/.*)?$'",
            "C": "Using the pattern '^https?://[a-zA-Z0-9-\\.]+\\.[a-zA-Z]{2,}$'",
            "D": "Using the pattern '^https?://[a-zA-Z0-9-\\.]+'"
        },
        "answer": "B",
        "explanation": "The pattern '^https?://[a-zA-Z0-9-\\.]+\\.[a-zA-Z]{2,}(/.*)?$' is commonly used to validate URLs, allowing for HTTP or HTTPS and including optional path components."
    },
    {
        "QN": "97",
        "type": "mcq",
        "question": "What is the difference between 're.search()' and 're.match()'?",
        "options": {
            "A": "'re.search()' searches the entire string, while 're.match()' only searches from the start",
            "B": "'re.search()' only searches from the start, while 're.match()' searches the entire string",
            "C": "'re.search()' is case-insensitive, while 're.match()' is case-sensitive",
            "D": "'re.search()' is used for replacing, while 're.match()' is used for searching"
        },
        "answer": "A",
        "explanation": "'re.search()' searches for the first occurrence of the pattern anywhere in the string, while 're.match()' searches for the pattern only at the beginning of the string."
    },
    {
        "QN": "98",
        "type": "mcq",
        "question": "What does the 're.fullmatch()' function do?",
        "options": {
            "A": "It searches for the first occurrence of a pattern in a string",
            "B": "It matches the entire string against a pattern",
            "C": "It replaces occurrences of a pattern",
            "D": "It splits a string using a pattern"
        },
        "answer": "B",
        "explanation": "The 're.fullmatch()' function matches the entire string against a pattern, returning a match object if the string matches the pattern completely."
    },
    {
        "QN": "99",
        "type": "mcq",
        "question": "What is the purpose of the 're.subn()' function?",
        "options": {
            "A": "To replace occurrences of a pattern and return the number of replacements",
            "B": "To search for a pattern in a string",
            "C": "To split a string using a pattern",
            "D": "To compile a regular expression pattern"
        },
        "answer": "A",
        "explanation": "The 're.subn()' function replaces occurrences of a pattern in a string and returns a tuple containing the new string and the number of substitutions made."
    },
    {
        "QN": "100",
        "type": "mcq",
        "question": "How can you match a string that contains only letters using regular expressions?",
        "options": {
            "A": "Using the pattern '^[a-zA-Z]+$'",
            "B": "Using the pattern '^[a-zA-Z]*$'",
            "C": "Using the pattern '^[a-zA-Z]?'",
            "D": "Using the pattern '^[a-zA-Z].*$'"
        },
        "answer": "A",
        "explanation": "The pattern '^[a-zA-Z]+$' matches any string that contains only letters from start to end."
    },
    {
        "QN": "101",
        "type": "mcq",
        "question": "What does the 're.finditer()' function do?",
        "options": {
            "A": "It returns an iterator yielding match objects for every occurrence of a pattern",
            "B": "It returns a list of all matches of a pattern",
            "C": "It searches for the first occurrence of a pattern",
            "D": "It replaces occurrences of a pattern"
        },
        "answer": "A",
        "explanation": "The 're.finditer()' function returns an iterator yielding match objects for every occurrence of a pattern in a string."
    },
    {
        "QN": "102",
        "type": "mcq",
        "question": "How can you match a string that contains at least one uppercase letter using regular expressions?",
        "options": {
            "A": "Using the pattern '.*[A-Z].*'",
            "B": "Using the pattern '[A-Z]+'",
            "C": "Using the pattern '[A-Z]*'",
            "D": "Using the pattern '[a-z]+'"
        },
        "answer": "A",
        "explanation": "The pattern '.*[A-Z].*' matches any string that contains at least one uppercase letter ('[A-Z]'). The '.*' before and after '[A-Z]' ensures that the string can contain characters before and after the uppercase letter."
    },
    {
        "QN": "103",
        "type": "mcq",
        "question": "What does the '\\A' special sequence represent in regular expressions?",
        "options": {
            "A": "Start of a string",
            "B": "End of a string",
            "C": "Start of a line",
            "D": "End of a line"
        },
        "answer": "A",
        "explanation": "The '\\A' special sequence represents the start of a string, similar to '^', but it always matches the start of the entire string, not just the start of each line in multiline mode."
    },
    {
        "QN": "104",
        "type": "mcq",
        "question": "What does the '\\Z' special sequence represent in regular expressions?",
        "options": {
            "A": "End of a string",
            "B": "Start of a string",
            "C": "End of a line",
            "D": "Start of a line"
        },
        "answer": "A",
        "explanation": "The '\\Z' special sequence represents the end of a string, similar to '$', but it always matches the end of the entire string, not just the end of each line in multiline mode."
    },
    {
        "QN": "105",
        "type": "mcq",
        "question": "How can you match a string that contains only digits using regular expressions?",
        "options": {
            "A": "Using the pattern '^\\d+$'",
            "B": "Using the pattern '^\\d*$'",
            "C": "Using the pattern '^\\d?'",
            "D": "Using the pattern '^\\d.*$'"
        },
        "answer": "A",
        "explanation": "The pattern '^\\d+$' matches any string that contains only digits from start to end."
    },
    {
        "QN": "106",
        "type": "mcq",
        "question": "How can you validate a date in the format 'YYYY-MM-DD' using regular expressions?",
        "options": {
            "A": "Using the pattern '^\\d{4}-\\d{2}-\\d{2}$'",
            "B": "Using the pattern '^\\d{4}-\\d{1,2}-\\d{1,2}$'",
            "C": "Using the pattern '^\\d{4}-\\d{2}-\\d{1,2}$'",
            "D": "Using the pattern '^\\d{4}-\\d{1,2}-\\d{2}$'"
        },
        "answer": "A",
        "explanation": "The pattern '^\\d{4}-\\d{2}-\\d{2}$' matches any string that is in the format 'YYYY-MM-DD', ensuring each part of the date has the correct number of digits."
    },
    {
        "QN": "107",
        "type": "mcq",
        "question": "What is the difference between 're.sub()' and 're.subn()'?",
        "options": {
            "A": "'re.sub()' returns the number of substitutions, while 're.subn()' returns the new string",
            "B": "'re.sub()' returns the new string, while 're.subn()' returns the new string and the number of substitutions",
            "C": "'re.sub()' is case-insensitive, while 're.subn()' is case-sensitive",
            "D": "'re.sub()' is used for searching, while 're.subn()' is used for replacing"
        },
        "answer": "B",
        "explanation": "'re.sub()' returns the new string after replacement, while 're.subn()' returns a tuple containing the new string and the number of substitutions made."
    },
    {
        "QN": "108",
        "type": "mcq",
        "question": "What does the 're.purge()' function do?",
        "options": {
            "A": "It clears the regular expression cache",
            "B": "It compiles a regular expression pattern",
            "C": "It searches for a pattern in a string",
            "D": "It replaces occurrences of a pattern"
        },
        "answer": "A",
        "explanation": "The 're.purge()' function clears the regular expression cache, which can be useful for freeing up memory if you're using a lot of different patterns."
    },
    {
        "QN": "109",
        "type": "mcq",
        "question": "How can you match a string that contains exactly three digits using regular expressions?",
        "options": {
            "A": "Using the pattern '^\\d{3}$'",
            "B": "Using the pattern '^\\d{3,}$'",
            "C": "Using the pattern '^\\d{3,5}$'",
            "D": "Using the pattern '^\\d{1,3}$'"
        },
        "answer": "A",
        "explanation": "The pattern '^\\d{3}$' matches any string that contains exactly three digits from start to end."
    },
    {
        "QN": "110",
        "type": "mcq",
        "question": "What does the 're.error' exception represent?",
        "options": {
            "A": "An error in the regular expression syntax",
            "B": "A match not found in the string",
            "C": "A memory error",
            "D": "A runtime error"
        },
        "answer": "A",
        "explanation": "The 're.error' exception is raised when there is an error in the regular expression syntax."
    },
    {
        "QN": "111",
        "type": "mcq",
        "question": "How can you match a string that contains at least two uppercase letters using regular expressions?",
        "options": {
            "A": "Using the pattern '^(?=.*[A-Z].*[A-Z]).*$'",
            "B": "Using the pattern '^[A-Z]{2,}$'",
            "C": "Using the pattern '^[A-Z]*$'",
            "D": "Using the pattern '^[a-z]{2,}$'"
        },
        "answer": "A",
        "explanation": "The pattern '^(?=.*[A-Z].*[A-Z]).*$' matches any string that contains at least two uppercase letters, using positive lookahead assertions."
    },
    {
        "QN": "112",
        "type": "mcq",
        "question": "What does the 're.TEMPLATE' flag do?",
        "options": {
            "A": "Makes the pattern case-insensitive",
            "B": "Makes the '^' and '$' anchors match the start and end of each line",
            "C": "Makes the '.' special character match any character including newline",
            "D": "Treats the pattern as a template, disabling backtracking"
        },
        "answer": "D",
        "explanation": "The 're.TEMPLATE' flag treats the pattern as a template, disabling backtracking, which can improve performance but may limit pattern flexibility."
    },
    {
        "QN": "113",
        "type": "mcq",
        "question": "How can you match a string that contains only hexadecimal digits using regular expressions?",
        "options": {
            "A": "Using the pattern '^[0-9a-fA-F]+$'",
            "B": "Using the pattern '^[0-9]+$'",
            "C": "Using the pattern '^[a-fA-F]+$'",
            "D": "Using the pattern '^[0-9a-zA-Z]+$'"
        },
        "answer": "A",
        "explanation": "The pattern '^[0-9a-fA-F]+$' matches any string that contains only hexadecimal digits from start to end."
    },
    {
        "QN": "114",
        "type": "mcq",
        "question": "What does the 're.VERBOSE' flag do?",
        "options": {
            "A": "Makes the pattern case-insensitive",
            "B": "Makes the '^' and '$' anchors match the start and end of each line",
            "C": "Makes the '.' special character match any character including newline",
            "D": "Allows whitespace and comments in the regular expression pattern"
        },
        "answer": "D",
        "explanation": "The 're.VERBOSE' flag allows whitespace and comments in the regular expression pattern, making it easier to read and understand complex patterns."
    },
    {
        "QN": "115",
        "type": "mcq",
        "question": "How can you match a string that contains exactly five alphanumeric characters using regular expressions?",
        "options": {
            "A": "Using the pattern '^\\w{5}$'",
            "B": "Using the pattern '^\\w{5,}$'",
            "C": "Using the pattern '^\\w{1,5}$'",
            "D": "Using the pattern '^\\w*$'"
        },
        "answer": "A",
        "explanation": "The pattern '^\\w{5}$' matches any string that contains exactly five alphanumeric characters (or underscores) from start to end."
    },
    {
        "QN": "116",
        "type": "mcq",
        "question": "How can you validate an IP address using regular expressions?",
        "options": {
            "A": "Using the pattern '^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$'",
            "B": "Using the pattern '^([0-9]{1,3}\\.){3}[0-9]{1,3}$'",
            "C": "Using the pattern '^([0-9]{1,3}\\.){3}[0-9]{1,3}$' with 're.VERBOSE' flag",
            "D": "Using the pattern '^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}$'"
        },
        "answer": "A",
        "explanation": "The pattern '^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$' is commonly used to validate IP addresses, ensuring each part is within the valid range of 0 to 255."
    },
    {
        "QN": "117",
        "type": "mcq",
        "question": "What is the difference between 're.search()' and 're.fullmatch()'?",
        "options": {
            "A": "'re.search()' searches the entire string, while 're.fullmatch()' matches the entire string",
            "B": "'re.search()' matches the entire string, while 're.fullmatch()' searches the entire string",
            "C": "'re.search()' is case-insensitive, while 're.fullmatch()' is case-sensitive",
            "D": "'re.search()' is used for replacing, while 're.fullmatch()' is used for searching"
        },
        "answer": "A",
        "explanation": "'re.search()' searches for the first occurrence of a pattern anywhere in the string, while 're.fullmatch()' matches the entire string against the pattern."
    },
    {
        "QN": "118",
        "type": "mcq",
        "question": "How can you match a string that contains at least one lowercase letter using regular expressions?",
        "options": {
            "A": "Using the pattern '.*[a-z].*'",
            "B": "Using the pattern '[a-z]+'",
            "C": "Using the pattern '[a-z]*'",
            "D": "Using the pattern '[A-Z]+'"
        },
        "answer": "A",
        "explanation": "The pattern '.*[a-z].*' matches any string that contains at least one lowercase letter ('[a-z]'). The '.*' before and after '[a-z]' ensures that the string can contain characters before and after the lowercase letter."
    },
    {
        "QN": "119",
        "type": "mcq",
        "question": "What does the 're.A' flag do?",
        "options": {
            "A": "Makes the pattern case-insensitive",
            "B": "Makes the '^' and '$' anchors match the start and end of each line",
            "C": "Makes the '.' special character match any character including newline",
            "D": "Makes the special sequences like '\\w', '\\W', '\\b', etc., match ASCII characters only"
        },
        "answer": "D",
        "explanation": "The 're.A' flag makes the special sequences like '\\w', '\\W', '\\b', etc., match ASCII characters only, which can be useful for ensuring that matches are limited to English characters."
    },
    {
        "QN": "120",
        "type": "mcq",
        "question": "How can you match a string that contains only letters and spaces using regular expressions?",
        "options": {
            "A": "Using the pattern '^[a-zA-Z\\s]+$'",
            "B": "Using the pattern '^[a-zA-Z]+$'",
            "C": "Using the pattern '^[a-zA-Z]*$'",
            "D": "Using the pattern '^[a-zA-Z\\s]*$'"
        },
        "answer": "A",
        "explanation": "The pattern '^[a-zA-Z\\s]+$' matches any string that contains only letters and spaces from start to end."
    },
    {
        "QN": "121",
        "type": "mcq",
        "question": "What does the 're.X' flag do?",
        "options": {
            "A": "Makes the pattern case-insensitive",
            "B": "Makes the '^' and '$' anchors match the start and end of each line",
            "C": "Makes the '.' special character match any character including newline",
            "D": "Allows whitespace and comments in the regular expression pattern"
        },
        "answer": "D",
        "explanation": "The 're.X' flag allows whitespace and comments in the regular expression pattern, making it easier to read and understand complex patterns."
    },
    {
        "QN": "122",
        "type": "mcq",
        "question": "How can you match a string that contains exactly four alphanumeric characters using regular expressions?",
        "options": {
            "A": "Using the pattern '^\\w{4}$'",
            "B": "Using the pattern '^\\w{4,}$'",
            "C": "Using the pattern '^\\w{1,4}$'",
            "D": "Using the pattern '^\\w*$'"
        },
        "answer": "A",
        "explanation": "The pattern '^\\w{4}$' matches any string that contains exactly four alphanumeric characters (or underscores) from start to end."
    },
    {
        "QN": "123",
        "type": "mcq",
        "question": "What does the 're.M' flag do?",
        "options": {
            "A": "Makes the pattern case-insensitive",
            "B": "Makes the '^' and '$' anchors match the start and end of each line",
            "C": "Makes the '.' special character match any character including newline",
            "D": "Ignores whitespace characters"
        },
        "answer": "B",
        "explanation": "The 're.M' flag makes the '^' and '$' anchors match the start and end of each line in a multiline string, not just the start and end of the entire string."
    },
    {
        "QN": "124",
        "type": "mcq",
        "question": "How can you match a string that contains at least one special character using regular expressions?",
        "options": {
            "A": "Using the pattern '.*[^a-zA-Z0-9].*'",
            "B": "Using the pattern '[a-zA-Z0-9]+'",
            "C": "Using the pattern '[a-zA-Z0-9]*'",
            "D": "Using the pattern '[a-zA-Z0-9]?'"
        },
        "answer": "A",
        "explanation": "The pattern '.*[^a-zA-Z0-9].*' matches any string that contains at least one character that is not a letter or digit, effectively matching special characters."
    },
    {
        "QN": "125",
        "type": "mcq",
        "question": "What does the 're.S' flag do?",
        "options": {
            "A": "Makes the pattern case-insensitive",
            "B": "Makes the '^' and '$' anchors match the start and end of each line",
            "C": "Makes the '.' special character match any character including newline",
            "D": "Ignores whitespace characters"
        },
        "answer": "C",
        "explanation": "The 're.S' flag makes the '.' special character match any character, including newline characters."
    },
    {
        "QN": "126",
        "type": "mcq",
        "question": "How can you validate a credit card number using regular expressions?",
        "options": {
            "A": "Using the pattern '^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13})$'",
            "B": "Using the pattern '^[0-9]{16}$'",
            "C": "Using the pattern '^[0-9]{13,16}$'",
            "D": "Using the pattern '^[0-9]{1,16}$'"
        },
        "answer": "A",
        "explanation": "The pattern '^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13})$' is commonly used to validate credit card numbers, supporting various card types like Visa, Mastercard, etc."
    },
    {
        "QN": "127",
        "type": "mcq",
        "question": "What is the difference between 're.findall()' and 're.finditer()'?",
        "options": {
            "A": "'re.findall()' returns a list of all matches, while 're.finditer()' returns an iterator yielding match objects",
            "B": "'re.findall()' returns an iterator yielding match objects, while 're.finditer()' returns a list of all matches",
            "C": "'re.findall()' is case-insensitive, while 're.finditer()' is case-sensitive",
            "D": "'re.findall()' is used for replacing, while 're.finditer()' is used for searching"
        },
        "answer": "A",
        "explanation": "'re.findall()' returns a list of all matches, while 're.finditer()' returns an iterator yielding match objects for every occurrence of the pattern."
    },
    {
        "QN": "128",
        "type": "mcq",
        "question": "How can you match a string that contains at least one digit and one letter using regular expressions?",
        "options": {
            "A": "Using the pattern '^(?=.*\\d)(?=.*[a-zA-Z]).*$'",
            "B": "Using the pattern '^[a-zA-Z0-9]+$'",
            "C": "Using the pattern '^[a-zA-Z]*$'",
            "D": "Using the pattern '^\\d*$'"
        },
        "answer": "A",
        "explanation": "The pattern '^(?=.*\\d)(?=.*[a-zA-Z]).*$' matches any string that contains at least one digit ('\\d') and one letter ('[a-zA-Z]'), using positive lookahead assertions."
    },
    {
        "QN": "129",
        "type": "mcq",
        "question": "What does the 're.U' flag do?",
        "options": {
            "A": "Makes the pattern case-insensitive",
            "B": "Makes the '^' and '$' anchors match the start and end of each line",
            "C": "Makes the '.' special character match any character including newline",
            "D": "Makes the special sequences like '\\w', '\\W', '\\b', etc., match Unicode characters"
        },
        "answer": "D",
        "explanation": "The 're.U' flag makes the special sequences like '\\w', '\\W', '\\b', etc., match Unicode characters, which can be useful for handling non-ASCII characters."
    },
    {
        "QN": "130",
        "type": "mcq",
        "question": "How can you match a string that contains only hexadecimal digits and letters using regular expressions?",
        "options": {
            "A": "Using the pattern '^[0-9a-fA-F]+$'",
            "B": "Using the pattern '^[0-9]+$'",
            "C": "Using the pattern '^[a-zA-Z]+$'",
            "D": "Using the pattern '^[0-9a-zA-Z]+$'"
        },
        "answer": "A",
        "explanation": "The pattern '^[0-9a-fA-F]+$' matches any string that contains only hexadecimal digits from start to end."
    },
    {
        "QN": "131",
        "type": "mcq",
        "question": "What does the 're.I' flag do?",
        "options": {
            "A": "Makes the pattern case-insensitive",
            "B": "Makes the '^' and '$' anchors match the start and end of each line",
            "C": "Makes the '.' special character match any character including newline",
            "D": "Ignores whitespace characters"
        },
        "answer": "A",
        "explanation": "The 're.I' flag makes the pattern case-insensitive, so it matches both lowercase and uppercase characters."
    },
    {
        "QN": "132",
        "type": "mcq",
        "question": "How can you match a string that contains exactly six alphanumeric characters using regular expressions?",
        "options": {
            "A": "Using the pattern '^\\w{6}$'",
            "B": "Using the pattern '^\\w{6,}$'",
            "C": "Using the pattern '^\\w{1,6}$'",
            "D": "Using the pattern '^\\w*$'"
        },
        "answer": "A",
        "explanation": "The pattern '^\\w{6}$' matches any string that contains exactly six alphanumeric characters (or underscores) from start to end."
    },
    {
        "QN": "133",
        "type": "mcq",
        "question": "What does the 're.ASCII' flag do?",
        "options": {
            "A": "Makes the pattern case-insensitive",
            "B": "Makes the '^' and '$' anchors match the start and end of each line",
            "C": "Makes the '.' special character match any character including newline",
            "D": "Makes the special sequences like '\\w', '\\W', '\\b', etc., match ASCII characters only"
        },
        "answer": "D",
        "explanation": "The 're.ASCII' flag makes the special sequences like '\\w', '\\W', '\\b', etc., match ASCII characters only, similar to 're.A'."
    },
    {
        "QN": "134",
        "type": "mcq",
        "question": "How can you match a string that contains at least one special character and one letter using regular expressions?",
        "options": {
            "A": "Using the pattern '^(?=.*[^a-zA-Z0-9])(?=.*[a-zA-Z]).*$'",
            "B": "Using the pattern '^[a-zA-Z0-9]+$'",
            "C": "Using the pattern '^[a-zA-Z]*$'",
            "D": "Using the pattern '^\\d*$'"
        },
        "answer": "A",
        "explanation": "The pattern '^(?=.*[^a-zA-Z0-9])(?=.*[a-zA-Z]).*$' matches any string that contains at least one special character ('[^a-zA-Z0-9]') and one letter ('[a-zA-Z]'), using positive lookahead assertions."
    },
    {
        "QN": "135",
        "type": "mcq",
        "question": "What does the 're.DOTALL' flag do?",
        "options": {
            "A": "Makes the pattern case-insensitive",
            "B": "Makes the '^' and '$' anchors match the start and end of each line",
            "C": "Makes the '.' special character match any character including newline",
            "D": "Ignores whitespace characters"
        },
        "answer": "C",
        "explanation": "The 're.DOTALL' flag makes the '.' special character match any character, including newline characters."
    },
    {
        "QN": "136",
        "type": "mcq",
        "question": "How can you validate an ISBN number using regular expressions?",
        "options": {
            "A": "Using the pattern '^(?:ISBN(?:-1[03])?:? )?(?=[0-9X]{10}$|(?=(?:[0-9]+[- ]){3})[- 0-9X]{13}$|97[89][0-9]{10}$|(?=(?:[0-9]+[- ]){4})[- 0-9]{17}$)(?:97[89][- ]?)?[0-9]{1,5}[- ]?[0-9]+[- ]?[0-9]+[- ]?[0-9X]$'",
            "B": "Using the pattern '^[0-9]{10}$'",
            "C": "Using the pattern '^[0-9]{13}$'",
            "D": "Using the pattern '^[0-9]{17}$'"
        },
        "answer": "A",
        "explanation": "The pattern for validating ISBN numbers is complex and must account for different formats and checksums."
    },
    {
        "QN": "137",
        "type": "mcq",
        "question": "What is the difference between 're.sub()' and string replacement methods like 'str.replace()'?",
        "options": {
            "A": "'re.sub()' uses regular expressions, while 'str.replace()' uses literal strings",
            "B": "'re.sub()' is case-insensitive, while 'str.replace()' is case-sensitive",
            "C": "'re.sub()' is used for searching, while 'str.replace()' is used for replacing",
            "D": "'re.sub()' is faster, while 'str.replace()' is slower"
        },
        "answer": "A",
        "explanation": "'re.sub()' uses regular expressions to match patterns, while 'str.replace()' uses literal strings for replacement."
    },
    {
        "QN": "138",
        "type": "mcq",
        "question": "How can you match a string that contains at least one digit and one uppercase letter using regular expressions?",
        "options": {
            "A": "Using the pattern '^(?=.*\\d)(?=.*[A-Z]).*$'",
            "B": "Using the pattern '^[a-zA-Z0-9]+$'",
            "C": "Using the pattern '^[a-zA-Z]*$'",
            "D": "Using the pattern '^\\d*$'"
        },
        "answer": "A",
        "explanation": "The pattern '^(?=.*\\d)(?=.*[A-Z]).*$' matches any string that contains at least one digit ('\\d') and one uppercase letter ('[A-Z]'), using positive lookahead assertions."
    },
    {
        "QN": "139",
        "type": "mcq",
        "question": "What does the 're.DEBUG' flag do?",
        "options": {
            "A": "Makes the pattern case-insensitive",
            "B": "Makes the '^' and '$' anchors match the start and end of each line",
            "C": "Makes the '.' special character match any character including newline",
            "D": "Displays debugging information about compiled regular expressions"
        },
        "answer": "D",
        "explanation": "The 're.DEBUG' flag displays debugging information about compiled regular expressions, which can be useful for understanding how patterns are interpreted."
    },
    {
        "QN": "140",
        "type": "mcq",
        "question": "How can you match a string that contains only hexadecimal digits and uppercase letters using regular expressions?",
        "options": {
            "A": "Using the pattern '^[0-9a-fA-F]+$'",
            "B": "Using the pattern '^[0-9A-F]+$'",
            "C": "Using the pattern '^[A-F]+$'",
            "D": "Using the pattern '^[0-9]+$'"
        },
        "answer": "B",
        "explanation": "The pattern '^[0-9A-F]+$' matches any string that contains only hexadecimal digits and uppercase letters from start to end."
    },
    {
        "QN": "141",
        "type": "mcq",
        "question": "How can you match a string that contains exactly seven alphanumeric characters using regular expressions?",
        "options": {
            "A": "Using the pattern '^\\w{7}$'",
            "B": "Using the pattern '^\\w{7,}$'",
            "C": "Using the pattern '^\\w{1,7}$'",
            "D": "Using the pattern '^\\w*$'"
        },
        "answer": "A",
        "explanation": "The pattern '^\\w{7}$' matches any string that contains exactly seven alphanumeric characters (or underscores) from start to end."
    },
    {
        "QN": "142",
        "type": "mcq",
        "question": "How can you match a string that contains at least one special character and one digit using regular expressions?",
        "options": {
            "A": "Using the pattern '^(?=.*[^a-zA-Z0-9])(?=.*\\d).*$'",
            "B": "Using the pattern '^[a-zA-Z0-9]+$'",
            "C": "Using the pattern '^[a-zA-Z]*$'",
            "D": "Using the pattern '^\\d*$'"
        },
        "answer": "A",
        "explanation": "The pattern '^(?=.*[^a-zA-Z0-9])(?=.*\\d).*$' matches any string that contains at least one special character ('[^a-zA-Z0-9]') and one digit ('\\d'), using positive lookahead assertions."
    },
    {
        "QN": "143",
        "type": "mcq",
        "question": "How can you validate a social security number using regular expressions?",
        "options": {
            "A": "Using the pattern '^\\d{3}-\\d{2}-\\d{4}$'",
            "B": "Using the pattern '^\\d{3}-\\d{2}-\\d{3}$'",
            "C": "Using the pattern '^\\d{3}\\s\\d{2}\\s\\d{4}$'",
            "D": "Using the pattern '^\\d{9}$'"
        },
        "answer": "A",
        "explanation": "The pattern '^\\d{3}-\\d{2}-\\d{4}$' matches any string that is in the format of a social security number, with dashes separating the parts."
    },
    {
        "QN": "144",
        "type": "mcq",
        "question": "What is the difference between using 're.search()' and 're.match()' with the 're.MULTILINE' flag?",
        "options": {
            "A": "'re.search()' searches the entire string, while 're.match()' only searches from the start in multiline mode",
            "B": "'re.search()' only searches from the start, while 're.match()' searches the entire string in multiline mode",
            "C": "'re.search()' is case-insensitive, while 're.match()' is case-sensitive in multiline mode",
            "D": "'re.search()' is used for replacing, while 're.match()' is used for searching in multiline mode"
        },
        "answer": "A",
        "explanation": "'re.search()' searches for the first occurrence of a pattern anywhere in the string, while 're.match()' searches for the pattern only at the beginning of each line in multiline mode."
    },
    {
        "QN": "145",
        "type": "mcq",
        "question": "How can you match a string that contains at least one digit and one lowercase letter using regular expressions?",
        "options": {
            "A": "Using the pattern '^(?=.*\\d)(?=.*[a-z]).*$'",
            "B": "Using the pattern '^[a-zA-Z0-9]+$'",
            "C": "Using the pattern '^[a-zA-Z]*$'",
            "D": "Using the pattern '^\\d*$'"
        },
        "answer": "A",
        "explanation": "The pattern '^(?=.*\\d)(?=.*[a-z]).*$' matches any string that contains at least one digit ('\\d') and one lowercase letter ('[a-z]'), using positive lookahead assertions."
    },
    {
        "QN": "146",
        "type": "mcq",
        "question": "What does the 're.IGNORECASE' flag do?",
        "options": {
            "A": "Makes the pattern case-insensitive",
            "B": "Makes the '^' and '$' anchors match the start and end of each line",
            "C": "Makes the '.' special character match any character including newline",
            "D": "Ignores whitespace characters"
        },
        "answer": "A",
        "explanation": "The 're.IGNORECASE' flag makes the pattern case-insensitive, so it matches both lowercase and uppercase characters."
    },
    {
        "QN": "147",
        "type": "mcq",
        "question": "How can you match a string that contains only hexadecimal digits and lowercase letters using regular expressions?",
        "options": {
            "A": "Using the pattern '^[0-9a-f]+$'",
            "B": "Using the pattern '^[0-9]+$'",
            "C": "Using the pattern '^[a-z]+$'",
            "D": "Using the pattern '^[0-9a-zA-Z]+$'"
        },
        "answer": "A",
        "explanation": "The pattern '^[0-9a-f]+$' matches any string that contains only hexadecimal digits and lowercase letters from start to end."
    },
    {
        "QN": "148",
        "type": "mcq",
        "question": "How can you match a string that contains exactly eight alphanumeric characters using regular expressions?",
        "options": {
            "A": "Using the pattern '^\\w{8}$'",
            "B": "Using the pattern '^\\w{8,}$'",
            "C": "Using the pattern '^\\w{1,8}$'",
            "D": "Using the pattern '^\\w*$'"
        },
        "answer": "A",
        "explanation": "The pattern '^\\w{8}$' matches any string that contains exactly eight alphanumeric characters (or underscores) from start to end."
    },
    {
        "QN": "149",
        "type": "mcq",
        "question": "How can you match a string that contains at least one special character and one uppercase letter using regular expressions?",
        "options": {
            "A": "Using the pattern '^(?=.*[^a-zA-Z0-9])(?=.*[A-Z]).*$'",
            "B": "Using the pattern '^[a-zA-Z0-9]+$'",
            "C": "Using the pattern '^[a-zA-Z]*$'",
            "D": "Using the pattern '^\\d*$'"
        },
        "answer": "A",
        "explanation": "The pattern '^(?=.*[^a-zA-Z0-9])(?=.*[A-Z]).*$' matches any string that contains at least one special character ('[^a-zA-Z0-9]') and one uppercase letter ('[A-Z]'), using positive lookahead assertions."
    },
    {
        "QN": "150",
        "type": "mcq",
        "question": "How can you validate a license plate number using regular expressions?",
        "options": {
            "A": "Using the pattern '^[A-Z]{3}-\\d{4}$'",
            "B": "Using the pattern '^[A-Z]{3}\\d{4}$'",
            "C": "Using the pattern '^[A-Z]{3}-[A-Z]{3}-\\d{4}$'",
            "D": "Using the pattern '^[A-Z]{3}-\\d{3}-\\d{4}$'"
        },
        "answer": "A",
        "explanation": "The pattern '^[A-Z]{3}-\\d{4}$' matches any string that is in the format of a typical license plate number with three letters followed by four digits."
    },
    {
        "QN": "151",
        "type": "mcq",
        "question": "What is the difference between using 're.findall()' and 're.finditer()' with capturing groups?",
        "options": {
            "A": "'re.findall()' returns a list of tuples for each group, while 're.finditer()' returns an iterator yielding match objects",
            "B": "'re.findall()' returns an iterator yielding match objects, while 're.finditer()' returns a list of tuples for each group",
            "C": "'re.findall()' is case-insensitive, while 're.finditer()' is case-sensitive",
            "D": "'re.findall()' is used for replacing, while 're.finditer()' is used for searching"
        },
        "answer": "A",
        "explanation": "'re.findall()' returns a list of tuples for each capturing group, while 're.finditer()' returns an iterator yielding match objects for every occurrence of the pattern."
    },
    {
        "QN": "152",
        "type": "mcq",
        "question": "How can you match a string that contains at least one digit and one special character using regular expressions?",
        "options": {
            "A": "Using the pattern '^(?=.*\\d)(?=.*[^a-zA-Z0-9]).*$'",
            "B": "Using the pattern '^[a-zA-Z0-9]+$'",
            "C": "Using the pattern '^[a-zA-Z]*$'",
            "D": "Using the pattern '^\\d*$'"
        },
        "answer": "A",
        "explanation": "The pattern '^(?=.*\\d)(?=.*[^a-zA-Z0-9]).*$' matches any string that contains at least one digit ('\\d') and one special character ('[^a-zA-Z0-9]'), using positive lookahead assertions."
    },
    {
        "QN": "153",
        "type": "mcq",
        "question": "How can you match a string that contains only hexadecimal digits and special characters using regular expressions?",
        "options": {
            "A": "Using the pattern '^[0-9a-fA-F][^a-zA-Z0-9]*$'",
            "B": "Using the pattern '^[0-9a-fA-F]+$'",
            "C": "Using the pattern '^[^a-zA-Z0-9]+$'",
            "D": "Using the pattern '^[0-9]+$'"
        },
        "answer": "C",
        "explanation": "The pattern '^[^a-zA-Z0-9]+$' matches any string that contains only special characters from start to end."
    },
    {
        "QN": "154",
        "type": "mcq",
        "question": "How can you match a string that contains exactly nine alphanumeric characters using regular expressions?",
        "options": {
            "A": "Using the pattern '^\\w{9}$'",
            "B": "Using the pattern '^\\w{9,}$'",
            "C": "Using the pattern '^\\w{1,9}$'",
            "D": "Using the pattern '^\\w*$'"
        },
        "answer": "A",
        "explanation": "The pattern '^\\w{9}$' matches any string that contains exactly nine alphanumeric characters (or underscores) from start to end."
    },
    {
        "QN": "155",
        "type": "mcq",
        "question": "How can you match a string that contains at least one special character and one lowercase letter using regular expressions?",
        "options": {
            "A": "Using the pattern '^(?=.*[^a-zA-Z0-9])(?=.*[a-z]).*$'",
            "B": "Using the pattern '^[a-zA-Z0-9]+$'",
            "C": "Using the pattern '^[a-zA-Z]*$'",
            "D": "Using the pattern '^\\d*$'"
        },
        "answer": "A",
        "explanation": "The pattern '^(?=.*[^a-zA-Z0-9])(?=.*[a-z]).*$' matches any string that contains at least one special character ('[^a-zA-Z0-9]') and one lowercase letter ('[a-z]'), using positive lookahead assertions."
    },
    {
        "QN": "156",
        "type": "mcq",
        "question": "How can you validate a VIN (Vehicle Identification Number) using regular expressions?",
        "options": {
            "A": "Using the pattern '^[A-HJ-NPR-Z0-9]{17}$'",
            "B": "Using the pattern '^[A-Z0-9]{17}$'",
            "C": "Using the pattern '^[A-Z0-9]{16}$'",
            "D": "Using the pattern '^[A-Z0-9]{15}$'"
        },
        "answer": "A",
        "explanation": "The pattern '^[A-HJ-NPR-Z0-9]{17}$' matches any string that is in the format of a typical VIN, excluding certain letters and ensuring it is 17 characters long."
    },
    {
        "QN": "157",
        "type": "mcq",
        "question": "What is the difference between using 're.sub()' with a replacement string versus a function?",
        "options": {
            "A": "Using a replacement string is faster, while using a function is slower",
            "B": "Using a replacement string is case-insensitive, while using a function is case-sensitive",
            "C": "Using a replacement string replaces literally, while using a function allows dynamic replacement based on the match",
            "D": "Using a replacement string is used for searching, while using a function is used for replacing"
        },
        "answer": "C",
        "explanation": "Using a replacement string with 're.sub()' replaces matches literally, while using a function allows for dynamic replacement based on the match."
    },
    {
        "QN": "158",
        "type": "mcq",
        "question": "How can you match a string that contains at least one digit and one uppercase letter and one lowercase letter using regular expressions?",
        "options": {
            "A": "Using the pattern '^(?=.*\\d)(?=.*[A-Z])(?=.*[a-z]).*$'",
            "B": "Using the pattern '^[a-zA-Z0-9]+$'",
            "C": "Using the pattern '^[a-zA-Z]*$'",
            "D": "Using the pattern '^\\d*$'"
        },
        "answer": "A",
        "explanation": "The pattern '^(?=.*\\d)(?=.*[A-Z])(?=.*[a-z]).*$' matches any string that contains at least one digit ('\\d'), one uppercase letter ('[A-Z]'), and one lowercase letter ('[a-z]'), using positive lookahead assertions."
    },
    {
        "QN": "159",
        "type": "mcq",
        "question": "How can you match a string that contains exactly ten alphanumeric characters using regular expressions?",
        "options": {
            "A": "Using the pattern '^\\w{10}$'",
            "B": "Using the pattern '^\\w{10,}$'",
            "C": "Using the pattern '^\\w{1,10}$'",
            "D": "Using the pattern '^\\w*$'"
        },
        "answer": "A",
        "explanation": "The pattern '^\\w{10}$' matches any string that contains exactly ten alphanumeric characters (or underscores) from start to end."
    },
    {
        "QN": "160",
        "type": "mcq",
        "question": "How can you match a string that contains at least one special character and one digit and one letter using regular expressions?",
        "options": {
            "A": "Using the pattern '^(?=.*[^a-zA-Z0-9])(?=.*\\d)(?=.*[a-zA-Z]).*$'",
            "B": "Using the pattern '^[a-zA-Z0-9]+$'",
            "C": "Using the pattern '^[a-zA-Z]*$'",
            "D": "Using the pattern '^\\d*$'"
        },
        "answer": "A",
        "explanation": "The pattern '^(?=.*[^a-zA-Z0-9])(?=.*\\d)(?=.*[a-zA-Z]).*$' matches any string that contains at least one special character ('[^a-zA-Z0-9]'), one digit ('\\d'), and one letter ('[a-zA-Z]'), using positive lookahead assertions."
    },
    {
        "QN": "161",
        "type": "mcq",
        "question": "How can you validate a passport number using regular expressions?",
        "options": {
            "A": "Using the pattern '^[A-Z]{2}[0-9]{9}$'",
            "B": "Using the pattern '^[A-Z]{1}[0-9]{9}$'",
            "C": "Using the pattern '^[A-Z]{3}[0-9]{6}$'",
            "D": "Using the pattern '^[A-Z]{2}[0-9]{6}$'"
        },
        "answer": "A",
        "explanation": "The pattern '^[A-Z]{2}[0-9]{9}$' matches any string that is in the format of a typical passport number, starting with two letters followed by nine digits."
    },
    {
        "QN": "162",
        "type": "mcq",
        "question": "What is the difference between using 're.sub()' with a replacement string versus a lambda function?",
        "options": {
            "A": "Using a replacement string is faster, while using a lambda function is slower",
            "B": "Using a replacement string replaces literally, while using a lambda function allows dynamic replacement based on the match",
            "C": "Using a replacement string is case-insensitive, while using a lambda function is case-sensitive",
            "D": "Using a replacement string is used for searching, while using a lambda function is used for replacing"
        },
        "answer": "B",
        "explanation": "Using a replacement string with 're.sub()' replaces matches literally, while using a lambda function allows for dynamic replacement based on the match."
    },
    {
        "QN": "163",
        "type": "mcq",
        "question": "How can you match a string that contains at least one digit, one uppercase letter, and one lowercase letter, and one special character using regular expressions?",
        "options": {
            "A": "Using the pattern '^(?=.*\\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[^a-zA-Z0-9]).*$'",
            "B": "Using the pattern '^[a-zA-Z0-9]+$'",
            "C": "Using the pattern '^[a-zA-Z]*$'",
            "D": "Using the pattern '^\\d*$'"
        },
        "answer": "A",
        "explanation": "The pattern '^(?=.*\\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[^a-zA-Z0-9]).*$' matches any string that contains at least one digit ('\\d'), one uppercase letter ('[A-Z]'), one lowercase letter ('[a-z]'), and one special character ('[^a-zA-Z0-9]'), using positive lookahead assertions."
    },
    {
        "QN": "164",
        "type": "mcq",
        "question": "How can you match a string that contains only hexadecimal digits and letters and special characters using regular expressions?",
        "options": {
            "A": "Using the pattern '^[0-9a-fA-Fa-zA-Z[^a-zA-Z0-9]]+$'",
            "B": "Using the pattern '^[0-9a-fA-F]+$'",
            "C": "Using the pattern '^[a-zA-Z]+$'",
            "D": "Using the pattern '^[0-9]+$'"
        },
        "answer": "A",
        "explanation": "The pattern '^[0-9a-fA-Fa-zA-Z[^a-zA-Z0-9]]+$' matches any string that contains hexadecimal digits, letters, and special characters from start to end."
    },
    {
        "QN": "165",
        "type": "mcq",
        "question": "How can you match a string that contains exactly eleven alphanumeric characters using regular expressions?",
        "options": {
            "A": "Using the pattern '^\\w{11}$'",
            "B": "Using the pattern '^\\w{11,}$'",
            "C": "Using the pattern '^\\w{1,11}$'",
            "D": "Using the pattern '^\\w*$'"
        },
        "answer": "A",
        "explanation": "The pattern '^\\w{11}$' matches any string that contains exactly eleven alphanumeric characters (or underscores) from start to end."
    },
    {
        "QN": "166",
        "type": "mcq",
        "question": "How can you match a string that contains at least one special character, one digit, one uppercase letter, and one lowercase letter using regular expressions?",
        "options": {
            "A": "Using the pattern '^(?=.*[^a-zA-Z0-9])(?=.*\\d)(?=.*[A-Z])(?=.*[a-z]).*$'",
            "B": "Using the pattern '^[a-zA-Z0-9]+$'",
            "C": "Using the pattern '^[a-zA-Z]*$'",
            "D": "Using the pattern '^\\d*$'"
        },
        "answer": "A",
        "explanation": "The pattern '^(?=.*[^a-zA-Z0-9])(?=.*\\d)(?=.*[A-Z])(?=.*[a-z]).*$' matches any string that contains at least one special character ('[^a-zA-Z0-9]'), one digit ('\\d'), one uppercase letter ('[A-Z]'), and one lowercase letter ('[a-z]'), using positive lookahead assertions."
    },
    {
        "QN": "167",
        "type": "mcq",
        "question": "How can you validate a driver's license number using regular expressions?",
        "options": {
            "A": "Using the pattern '^[A-Z]{3}[0-9]{7}$'",
            "B": "Using the pattern '^[A-Z]{2}[0-9]{6}$'",
            "C": "Using the pattern '^[A-Z]{1}[0-9]{7}$'",
            "D": "Using the pattern '^[A-Z]{2}[0-9]{7}$'"
        },
        "answer": "D",
        "explanation": "The pattern '^[A-Z]{2}[0-9]{7}$' matches any string that is in the format of a typical driver's license number, starting with two letters followed by seven digits."
    },
    {
        "QN": "168",
        "type": "mcq",
        "question": "What is the difference between using 're.sub()' with a replacement string versus a lambda function that uses the match object?",
        "options": {
            "A": "Using a replacement string is faster, while using a lambda function is slower",
            "B": "Using a replacement string replaces literally, while using a lambda function allows dynamic replacement based on the match",
            "C": "Using a replacement string is case-insensitive, while using a lambda function is case-sensitive",
            "D": "Using a replacement string is used for searching, while using a lambda function is used for replacing"
        },
        "answer": "B",
        "explanation": "Using a replacement string with 're.sub()' replaces matches literally, while using a lambda function allows for dynamic replacement based on the match."
    },
    {
        "QN": "169",
        "type": "mcq",
        "question": "How can you match a string that contains at least one digit, one uppercase letter, one lowercase letter, and one special character, and is at least five characters long using regular expressions?",
        "options": {
            "A": "Using the pattern '^(?=.*\\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[^a-zA-Z0-9]).{5,}$'",
            "B": "Using the pattern '^[a-zA-Z0-9]+$'",
            "C": "Using the pattern '^[a-zA-Z]*$'",
            "D": "Using the pattern '^\\d*$'"
        },
        "answer": "A",
        "explanation": "The pattern '^(?=.*\\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[^a-zA-Z0-9]).{5,}$' matches any string that contains at least one digit ('\\d'), one uppercase letter ('[A-Z]'), one lowercase letter ('[a-z]'), one special character ('[^a-zA-Z0-9]'), and is at least five characters long, using positive lookahead assertions."
    },
    {
        "QN": "170",
        "type": "mcq",
        "question": "How can you match a string that contains only hexadecimal digits, letters, and special characters using regular expressions?",
        "options": {
            "A": "Using the pattern '^[0-9a-fA-Fa-zA-Z[^a-zA-Z0-9]]+$'",
            "B": "Using the pattern '^[0-9a-fA-F]+$'",
            "C": "Using the pattern '^[a-zA-Z]+$'",
            "D": "Using the pattern '^[0-9]+$'"
        },
        "answer": "A",
        "explanation": "The pattern '^[0-9a-fA-Fa-zA-Z[^a-zA-Z0-9]]+$' matches any string that contains hexadecimal digits, letters, and special characters from start to end."
    },
    {
        "QN": "171",
        "type": "mcq",
        "question": "How can you match a string that contains exactly twelve alphanumeric characters using regular expressions?",
        "options": {
            "A": "Using the pattern '^\\w{12}$'",
            "B": "Using the pattern '^\\w{12,}$'",
            "C": "Using the pattern '^\\w{1,12}$'",
            "D": "Using the pattern '^\\w*$'"
        },
        "answer": "A",
        "explanation": "The pattern '^\\w{12}$' matches any string that contains exactly twelve alphanumeric characters (or underscores) from start to end."
    },
    {
        "QN": "172",
        "type": "mcq",
        "question": "How can you validate a bank account number using regular expressions?",
        "options": {
            "A": "Using the pattern '^[0-9]{16}$'",
            "B": "Using the pattern '^[0-9]{13}$'",
            "C": "Using the pattern '^[0-9]{10}$'",
            "D": "Using the pattern '^[0-9]{12}$'"
        },
        "answer": "A",
        "explanation": "The pattern '^[0-9]{16}$' matches any string that is a typical 16-digit bank account number."
    },
    {
        "QN": "173",
        "type": "mcq",
        "question": "What is the difference between using 're.sub()' with a replacement string versus a lambda function that uses the match object's groups?",
        "options": {
            "A": "Using a replacement string is faster, while using a lambda function is slower",
            "B": "Using a replacement string replaces literally, while using a lambda function allows dynamic replacement based on the match groups",
            "C": "Using a replacement string is case-insensitive, while using a lambda function is case-sensitive",
            "D": "Using a replacement string is used for searching, while using a lambda function is used for replacing"
        },
        "answer": "B",
        "explanation": "Using a replacement string with 're.sub()' replaces matches literally, while using a lambda function allows for dynamic replacement based on the match groups."
    },
    {
        "QN": "174",
        "type": "mcq",
        "question": "How can you match a string that contains at least one digit, one uppercase letter, one lowercase letter, and one special character, and is exactly ten characters long using regular expressions?",
        "options": {
            "A": "Using the pattern '^(?=.*\\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[^a-zA-Z0-9]).{10}$'",
            "B": "Using the pattern '^[a-zA-Z0-9]+$'",
            "C": "Using the pattern '^[a-zA-Z]*$'",
            "D": "Using the pattern '^\\d*$'"
        },
        "answer": "A",
        "explanation": "The pattern '^(?=.*\\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[^a-zA-Z0-9]).{10}$' matches any string that contains at least one digit ('\\d'), one uppercase letter ('[A-Z]'), one lowercase letter ('[a-z]'), one special character ('[^a-zA-Z0-9]'), and is exactly ten characters long, using positive lookahead assertions."
    },
    {
        "QN": "175",
        "type": "mcq",
        "question": "How can you match a string that contains exactly thirteen alphanumeric characters using regular expressions?",
        "options": {
            "A": "Using the pattern '^\\w{13}$'",
            "B": "Using the pattern '^\\w{13,}$'",
            "C": "Using the pattern '^\\w{1,13}$'",
            "D": "Using the pattern '^\\w*$'"
        },
        "answer": "A",
        "explanation": "The pattern '^\\w{13}$' matches any string that contains exactly thirteen alphanumeric characters (or underscores) from start to end."
    },
    {
        "QN": "176",
        "type": "mcq",
        "question": "How can you validate an IMEI number using regular expressions?",
        "options": {
            "A": "Using the pattern '^[0-9]{15}$'",
            "B": "Using the pattern '^[0-9]{14}$'",
            "C": "Using the pattern '^[0-9]{16}$'",
            "D": "Using the pattern '^[0-9]{17}$'"
        },
        "answer": "A",
        "explanation": "The pattern '^[0-9]{15}$' matches any string that is a typical 15-digit IMEI number."
    },
    {
        "QN": "177",
        "type": "mcq",
        "question": "What is the difference between using 're.sub()' with a replacement string versus a lambda function that uses the match object's groups and captures?",
        "options": {
            "A": "Using a replacement string is faster, while using a lambda function is slower",
            "B": "Using a replacement string replaces literally, while using a lambda function allows dynamic replacement based on the match groups and captures",
            "C": "Using a replacement string is case-insensitive, while using a lambda function is case-sensitive",
            "D": "Using a replacement string is used for searching, while using a lambda function is used for replacing"
        },
        "answer": "B",
        "explanation": "Using a replacement string with 're.sub()' replaces matches literally, while using a lambda function allows for dynamic replacement based on the match groups and captures."
    },
    {
        "QN": "178",
        "type": "mcq",
        "question": "How can you match a string that contains at least one digit, one uppercase letter, one lowercase letter, and one special character, and is between five and ten characters long using regular expressions?",
        "options": {
            "A": "Using the pattern '^(?=.*\\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[^a-zA-Z0-9]).{5,10}$'",
            "B": "Using the pattern '^[a-zA-Z0-9]+$'",
            "C": "Using the pattern '^[a-zA-Z]*$'",
            "D": "Using the pattern '^\\d*$'"
        },
        "answer": "A",
        "explanation": "The pattern '^(?=.*\\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[^a-zA-Z0-9]).{5,10}$' matches any string that contains at least one digit ('\\d'), one uppercase letter ('[A-Z]'), one lowercase letter ('[a-z]'), one special character ('[^a-zA-Z0-9]'), and is between five and ten characters long, using positive lookahead assertions."
    },
    {
        "QN": "179",
        "type": "mcq",
        "question": "How can you match a string that contains exactly fourteen alphanumeric characters using regular expressions?",
        "options": {
            "A": "Using the pattern '^\\w{14}$'",
            "B": "Using the pattern '^\\w{14,}$'",
            "C": "Using the pattern '^\\w{1,14}$'",
            "D": "Using the pattern '^\\w*$'"
        },
        "answer": "A",
        "explanation": "The pattern '^\\w{14}$' matches any string that contains exactly fourteen alphanumeric characters (or underscores) from start to end."
    },
    {
        "QN": "180",
        "type": "mcq",
        "question": "How can you validate a serial number using regular expressions?",
        "options": {
            "A": "Using the pattern '^[A-Z]{2}[0-9]{6}$'",
            "B": "Using the pattern '^[A-Z]{3}[0-9]{5}$'",
            "C": "Using the pattern '^[A-Z]{1}[0-9]{7}$'",
            "D": "Using the pattern '^[A-Z]{2}[0-9]{7}$'"
        },
        "answer": "D",
        "explanation": "The pattern '^[A-Z]{2}[0-9]{7}$' matches any string that is in the format of a typical serial number, starting with two letters followed by seven digits."
    },
    {
        "QN": "181",
        "type": "mcq",
        "question": "What is the difference between using 're.sub()' with a replacement string versus a lambda function that uses the match object's groups and captures for conditional replacement?",
        "options": {
            "A": "Using a replacement string is faster, while using a lambda function is slower",
            "B": "Using a replacement string replaces literally, while using a lambda function allows dynamic replacement based on the match groups and captures for conditional logic",
            "C": "Using a replacement string is case-insensitive, while using a lambda function is case-sensitive",
            "D": "Using a replacement string is used for searching, while using a lambda function is used for replacing"
        },
        "answer": "B",
        "explanation": "Using a replacement string with 're.sub()' replaces matches literally, while using a lambda function allows for dynamic replacement based on the match groups and captures, enabling conditional logic."
    },
    {
        "QN": "182",
        "type": "mcq",
        "question": "How can you match a string that contains at least one digit, one uppercase letter, one lowercase letter, and one special character, and is between eight and twelve characters long using regular expressions?",
        "options": {
            "A": "Using the pattern '^(?=.*\\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[^a-zA-Z0-9]).{8,12}$'",
            "B": "Using the pattern '^[a-zA-Z0-9]+$'",
            "C": "Using the pattern '^[a-zA-Z]*$'",
            "D": "Using the pattern '^\\d*$'"
        },
        "answer": "A",
        "explanation": "The pattern '^(?=.*\\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[^a-zA-Z0-9]).{8,12}$' matches any string that contains at least one digit ('\\d'), one uppercase letter ('[A-Z]'), one lowercase letter ('[a-z]'), one special character ('[^a-zA-Z0-9]'), and is between eight and twelve characters long, using positive lookahead assertions."
    },
    {
        "QN": "183",
        "type": "mcq",
        "question": "How can you match a string that contains exactly fifteen alphanumeric characters using regular expressions?",
        "options": {
            "A": "Using the pattern '^\\w{15}$'",
            "B": "Using the pattern '^\\w{15,}$'",
            "C": "Using the pattern '^\\w{1,15}$'",
            "D": "Using the pattern '^\\w*$'"
        },
        "answer": "A",
        "explanation": "The pattern '^\\w{15}$' matches any string that contains exactly fifteen alphanumeric characters (or underscores) from start to end."
    },
    {
        "QN": "184",
        "type": "mcq",
        "question": "How can you validate a product code using regular expressions?",
        "options": {
            "A": "Using the pattern '^[A-Z]{3}[0-9]{5}$'",
            "B": "Using the pattern '^[A-Z]{2}[0-9]{6}$'",
            "C": "Using the pattern '^[A-Z]{1}[0-9]{7}$'",
            "D": "Using the pattern '^[A-Z]{2}[0-9]{7}$'"
        },
        "answer": "B",
        "explanation": "The pattern '^[A-Z]{2}[0-9]{6}$' matches any string that is in the format of a typical product code, starting with two letters followed by six digits."
    },
    {
        "QN": "185",
        "type": "mcq",
        "question": "What is the difference between using 're.sub()' with a replacement string versus a lambda function that uses the match object's groups and captures for conditional logic with multiple conditions?",
        "options": {
            "A": "Using a replacement string is faster, while using a lambda function is slower",
            "B": "Using a replacement string replaces literally, while using a lambda function allows dynamic replacement based on the match groups and captures with conditional logic for multiple conditions",
            "C": "Using a replacement string is case-insensitive, while using a lambda function is case-sensitive",
            "D": "Using a replacement string is used for searching, while using a lambda function is used for replacing"
        },
        "answer": "B",
        "explanation": "Using a replacement string with 're.sub()' replaces matches literally, while using a lambda function allows for dynamic replacement based on the match groups and captures, enabling complex conditional logic for multiple conditions."
    },
    {
        "QN": "186",
        "type": "mcq",
        "question": "How can you match a string that contains at least one digit, one uppercase letter, one lowercase letter, and one special character, and is between nine and thirteen characters long using regular expressions?",
        "options": {
            "A": "Using the pattern '^(?=.*\\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[^a-zA-Z0-9]).{9,13}$'",
            "B": "Using the pattern '^[a-zA-Z0-9]+$'",
            "C": "Using the pattern '^[a-zA-Z]*$'",
            "D": "Using the pattern '^\\d*$'"
        },
        "answer": "A",
        "explanation": "The pattern '^(?=.*\\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[^a-zA-Z0-9]).{9,13}$' matches any string that contains at least one digit ('\\d'), one uppercase letter ('[A-Z]'), one lowercase letter ('[a-z]'), one special character ('[^a-zA-Z0-9]'), and is between nine and thirteen characters long, using positive lookahead assertions."
    },
    {
        "QN": "187",
        "type": "mcq",
        "question": "How can you match a string that contains exactly sixteen alphanumeric characters using regular expressions?",
        "options": {
            "A": "Using the pattern '^\\w{16}$'",
            "B": "Using the pattern '^\\w{16,}$'",
            "C": "Using the pattern '^\\w{1,16}$'",
            "D": "Using the pattern '^\\w*$'"
        },
        "answer": "A",
        "explanation": "The pattern '^\\w{16}$' matches any string that contains exactly sixteen alphanumeric characters (or underscores) from start to end."
    },
    {
        "QN": "188",
        "type": "mcq",
        "question": "How can you validate a coupon code using regular expressions?",
        "options": {
            "A": "Using the pattern '^[A-Z]{2}[0-9]{4}[A-Z]{2}$'",
            "B": "Using the pattern '^[A-Z]{3}[0-9]{3}[A-Z]{3}$'",
            "C": "Using the pattern '^[A-Z]{1}[0-9]{5}[A-Z]{1}$'",
            "D": "Using the pattern '^[A-Z]{2}[0-9]{5}[A-Z]{2}$'"
        },
        "answer": "D",
        "explanation": "The pattern '^[A-Z]{2}[0-9]{5}[A-Z]{2}$' matches any string that is in the format of a typical coupon code, starting with two letters followed by five digits and ending with two letters."
    },
    {
        "QN": "189",
        "type": "mcq",
        "question": "What is the difference between using 're.sub()' with a replacement string versus a lambda function that uses the match object's groups and captures for conditional logic with multiple conditions and error handling?",
        "options": {
            "A": "Using a replacement string is faster, while using a lambda function is slower",
            "B": "Using a replacement string replaces literally, while using a lambda function allows dynamic replacement based on the match groups and captures with conditional logic for multiple conditions and error handling",
            "C": "Using a replacement string is case-insensitive, while using a lambda function is case-sensitive",
            "D": "Using a replacement string is used for searching, while using a lambda function is used for replacing"
        },
        "answer": "B",
        "explanation": "Using a replacement string with 're.sub()' replaces matches literally, while using a lambda function allows for dynamic replacement based on the match groups and captures, enabling complex conditional logic for multiple conditions and error handling."
    },
    {
        "QN": "190",
        "type": "mcq",
        "question": "How can you match a string that contains at least one digit, one uppercase letter, one lowercase letter, and one special character, and is between ten and fifteen characters long using regular expressions?",
        "options": {
            "A": "Using the pattern '^(?=.*\\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[^a-zA-Z0-9]).{10,15}$'",
            "B": "Using the pattern '^[a-zA-Z0-9]+$'",
            "C": "Using the pattern '^[a-zA-Z]*$'",
            "D": "Using the pattern '^\\d*$'"
        },
        "answer": "A",
        "explanation": "The pattern '^(?=.*\\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[^a-zA-Z0-9]).{10,15}$' matches any string that contains at least one digit ('\\d'), one uppercase letter ('[A-Z]'), one lowercase letter ('[a-z]'), one special character ('[^a-zA-Z0-9]'), and is between ten and fifteen characters long, using positive lookahead assertions."
    },
    {
        "QN": "191",
        "type": "mcq",
        "question": "How can you match a string that contains exactly seventeen alphanumeric characters using regular expressions?",
        "options": {
            "A": "Using the pattern '^\\w{17}$'",
            "B": "Using the pattern '^\\w{17,}$'",
            "C": "Using the pattern '^\\w{1,17}$'",
            "D": "Using the pattern '^\\w*$'"
        },
        "answer": "A",
        "explanation": "The pattern '^\\w{17}$' matches any string that contains exactly seventeen alphanumeric characters (or underscores) from start to end."
    },
    {
        "QN": "192",
        "type": "mcq",
        "question": "How can you validate a gift card number using regular expressions?",
        "options": {
            "A": "Using the pattern '^[0-9]{16}$'",
            "B": "Using the pattern '^[0-9]{13}$'",
            "C": "Using the pattern '^[0-9]{15}$'",
            "D": "Using the pattern '^[0-9]{19}$'"
        },
        "answer": "A",
        "explanation": "The pattern '^[0-9]{16}$' matches any string that is a typical 16-digit gift card number."
    },
    {
        "QN": "193",
        "type": "mcq",
        "question": "What is the difference between using 're.sub()' with a replacement string versus a lambda function that uses the match object's groups and captures for conditional logic with multiple conditions, error handling, and logging?",
        "options": {
            "A": "Using a replacement string is faster, while using a lambda function is slower",
            "B": "Using a replacement string replaces literally, while using a lambda function allows dynamic replacement based on the match groups and captures with conditional logic for multiple conditions, error handling, and logging",
            "C": "Using a replacement string is case-insensitive, while using a lambda function is case-sensitive",
            "D": "Using a replacement string is used for searching, while using a lambda function is used for replacing"
        },
        "answer": "B",
        "explanation": "Using a replacement string with 're.sub()' replaces matches literally, while using a lambda function allows for dynamic replacement based on the match groups and captures, enabling complex conditional logic for multiple conditions, error handling, and logging."
    },
    {
        "QN": "194",
        "type": "mcq",
        "question": "How can you match a string that contains at least one digit, one uppercase letter, one lowercase letter, and one special character, and is between eleven and sixteen characters long using regular expressions?",
        "options": {
            "A": "Using the pattern '^(?=.*\\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[^a-zA-Z0-9]).{11,16}$'",
            "B": "Using the pattern '^[a-zA-Z0-9]+$'",
            "C": "Using the pattern '^[a-zA-Z]*$'",
            "D": "Using the pattern '^\\d*$'"
        },
        "answer": "A",
        "explanation": "The pattern '^(?=.*\\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[^a-zA-Z0-9]).{11,16}$' matches any string that contains at least one digit ('\\d'), one uppercase letter ('[A-Z]'), one lowercase letter ('[a-z]'), one special character ('[^a-zA-Z0-9]'), and is between eleven and sixteen characters long, using positive lookahead assertions."
    },
    {
        "QN": "195",
        "type": "mcq",
        "question": "How can you match a string that contains exactly eighteen alphanumeric characters using regular expressions?",
        "options": {
            "A": "Using the pattern '^\\w{18}$'",
            "B": "Using the pattern '^\\w{18,}$'",
            "C": "Using the pattern '^\\w{1,18}$'",
            "D": "Using the pattern '^\\w*$'"
        },
        "answer": "A",
        "explanation": "The pattern '^\\w{18}$' matches any string that contains exactly eighteen alphanumeric characters (or underscores) from start to end."
    },
    {
        "QN": "196",
        "type": "mcq",
        "question": "How can you validate a membership ID using regular expressions?",
        "options": {
            "A": "Using the pattern '^[A-Z]{2}[0-9]{8}$'",
            "B": "Using the pattern '^[A-Z]{3}[0-9]{6}$'",
            "C": "Using the pattern '^[A-Z]{1}[0-9]{9}$'",
            "D": "Using the pattern '^[A-Z]{2}[0-9]{9}$'"
        },
        "answer": "D",
        "explanation": "The pattern '^[A-Z]{2}[0-9]{9}$' matches any string that is in the format of a typical membership ID, starting with two letters followed by nine digits."
    },
    {
        "QN": "197",
        "type": "mcq",
        "question": "What is the difference between using 're.sub()' with a replacement string versus a lambda function that uses the match object's groups and captures for conditional logic with multiple conditions, error handling, logging, and input validation?",
        "options": {
            "A": "Using a replacement string is faster, while using a lambda function is slower",
            "B": "Using a replacement string replaces literally, while using a lambda function allows dynamic replacement based on the match groups and captures with conditional logic for multiple conditions, error handling, logging, and input validation",
            "C": "Using a replacement string is case-insensitive, while using a lambda function is case-sensitive",
            "D": "Using a replacement string is used for searching, while using a lambda function is used for replacing"
        },
        "answer": "B",
        "explanation": "Using a replacement string with 're.sub()' replaces matches literally, while using a lambda function allows for dynamic replacement based on the match groups and captures, enabling complex conditional logic for multiple conditions, error handling, logging, and input validation."
    },
    {
        "QN": "198",
        "type": "mcq",
        "question": "How can you match a string that contains at least one digit, one uppercase letter, one lowercase letter, and one special character, and is between twelve and seventeen characters long using regular expressions?",
        "options": {
            "A": "Using the pattern '^(?=.*\\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[^a-zA-Z0-9]).{12,17}$'",
            "B": "Using the pattern '^[a-zA-Z0-9]+$'",
            "C": "Using the pattern '^[a-zA-Z]*$'",
            "D": "Using the pattern '^\\d*$'"
        },
        "answer": "A",
        "explanation": "The pattern '^(?=.*\\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[^a-zA-Z0-9]).{12,17}$' matches any string that contains at least one digit ('\\d'), one uppercase letter ('[A-Z]'), one lowercase letter ('[a-z]'), one special character ('[^a-zA-Z0-9]'), and is between twelve and seventeen characters long, using positive lookahead assertions."
    },
    {
        "QN": "199",
        "type": "mcq",
        "question": "How can you match a string that contains exactly nineteen alphanumeric characters using regular expressions?",
        "options": {
            "A": "Using the pattern '^\\w{19}$'",
            "B": "Using the pattern '^\\w{19,}$'",
            "C": "Using the pattern '^\\w{1,19}$'",
            "D": "Using the pattern '^\\w*$'"
        },
        "answer": "A",
        "explanation": "The pattern '^\\w{19}$' matches any string that contains exactly nineteen alphanumeric characters (or underscores) from start to end."
    },
    {
        "QN": "200",
        "type": "mcq",
        "question": "How can you validate a membership code using regular expressions?",
        "options": {
            "A": "Using the pattern '^[A-Z]{3}[0-9]{6}$'",
            "B": "Using the pattern '^[A-Z]{2}[0-9]{7}$'",
            "C": "Using the pattern '^[A-Z]{1}[0-9]{8}$'",
            "D": "Using the pattern '^[A-Z]{2}[0-9]{8}$'"
        },
        "answer": "D",
        "explanation": "The pattern '^[A-Z]{2}[0-9]{8}$' matches any string that is in the format of a typical membership code, starting with two letters followed by eight digits."
    },
    {
        "QN": "201",
        "type": "mcq",
        "question": "What is the difference between using 're.sub()' with a replacement string versus a lambda function that uses the match object's groups and captures for conditional logic with multiple conditions, error handling, logging, input validation, and exception handling?",
        "options": {
            "A": "Using a replacement string is faster, while using a lambda function is slower",
            "B": "Using a replacement string replaces literally, while using a lambda function allows dynamic replacement based on the match groups and captures with conditional logic for multiple conditions, error handling, logging, input validation, and exception handling",
            "C": "Using a replacement string is case-insensitive, while using a lambda function is case-sensitive",
            "D": "Using a replacement string is used for searching, while using a lambda function is used for replacing"
        },
        "answer": "B",
        "explanation": "Using a replacement string with 're.sub()' replaces matches literally, while using a lambda function allows for dynamic replacement based on the match groups and captures, enabling complex conditional logic for multiple conditions, error handling, logging, input validation, and exception handling."
    },
    {
        "QN": "202",
        "type": "mcq",
        "question": "How can you match a string that contains at least one digit, one uppercase letter, one lowercase letter, and one special character, and is between thirteen and eighteen characters long using regular expressions?",
        "options": {
            "A": "Using the pattern '^(?=.*\\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[^a-zA-Z0-9]).{13,18}$'",
            "B": "Using the pattern '^[a-zA-Z0-9]+$'",
            "C": "Using the pattern '^[a-zA-Z]*$'",
            "D": "Using the pattern '^\\d*$'"
        },
        "answer": "A",
        "explanation": "The pattern '^(?=.*\\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[^a-zA-Z0-9]).{13,18}$' matches any string that contains at least one digit ('\\d'), one uppercase letter ('[A-Z]'), one lowercase letter ('[a-z]'), one special character ('[^a-zA-Z0-9]'), and is between thirteen and eighteen characters long, using positive lookahead assertions."
    },
    {
        "QN": "203",
        "type": "mcq",
        "question": "What is the difference between using 're.sub()' with a replacement string versus a lambda function that uses the match object's groups and captures for conditional logic with multiple conditions, error handling, logging, input validation, exception handling, and performance optimization?",
        "options": {
            "A": "Using a replacement string is faster, while using a lambda function is slower",
            "B": "Using a replacement string replaces literally, while using a lambda function allows dynamic replacement based on the match groups and captures with conditional logic for multiple conditions, error handling, logging, input validation, exception handling, and performance optimization",
            "C": "Using a replacement string is case-insensitive, while using a lambda function is case-sensitive",
            "D": "Using a replacement string is used for searching, while using a lambda function is used for replacing"
        },
        "answer": "B",
        "explanation": "Using a replacement string with 're.sub()' replaces matches literally, while using a lambda function allows for dynamic replacement based on the match groups and captures, enabling complex conditional logic for multiple conditions, error handling, logging, input validation, exception handling, and performance optimization."
    },
    {
        "QN": "204",
        "type": "mcq",
        "question": "Which module in Python supports regular expressions?",
        "options": {
            "A": "re",
            "B": "regex",
            "C": "pyregex",
            "D": "none of the mentioned"
        },
        "answer": "A",
        "explanation": "re is a part of the standard library and can be imported using: import re."
    },
    {
        "QN": "205",
        "type": "mcq",
        "question": "Which of the following creates a pattern object?",
        "options": {
            "A": "re.create(str)",
            "B": "re.regex(str)",
            "C": "re.compile(str)",
            "D": "re.assemble(str)"
        },
        "answer": "C",
        "explanation": "It converts a given string into a pattern object."
    },
    {
        "QN": "206",
        "type": "mcq",
        "question": "What does the function re.match do?",
        "options": {
            "A": "matches a pattern at the start of the string",
            "B": "matches a pattern at any position in the string",
            "C": "such a function does not exist",
            "D": "none of the mentioned"
        },
        "answer": "A",
        "explanation": "It will look for the pattern at the beginning and return None if it isn\u2019t found."
    },
    {
        "QN": "207",
        "type": "mcq",
        "question": "What does the function re.search do?",
        "options": {
            "A": "matches a pattern at the start of the string",
            "B": "matches a pattern at any position in the string",
            "C": "such a function does not exist",
            "D": "none of the mentioned"
        },
        "answer": "B",
        "explanation": "It will look for the pattern at any position in the string."
    },
    {
        "QN": "208",
        "type": "mcq",
        "question": "What will be the output of the following Python code?\n\nsentence = 'we are humans'\nmatched = re.match(r'(.*) (.*?) (.*)', sentence)\nprint(matched.groups())",
        "options": {
            "A": "('we', 'are', 'humans')",
            "B": "(we, are, humans)",
            "C": "('we', 'humans')",
            "D": "'we are humans'"
        },
        "answer": "A",
        "explanation": "This function returns all the subgroups that have been matched."
    },
    {
        "QN": "209",
        "type": "mcq",
        "question": "What will be the output of the following Python code?\n\nsentence = 'we are humans'\nmatched = re.match(r'(.*) (.*?) (.*)', sentence)\nprint(matched.group())",
        "options": {
            "A": "('we', 'are', 'humans')",
            "B": "(we, are, humans)",
            "C": "('we', 'humans')",
            "D": "'we are humans'"
        },
        "answer": "D",
        "explanation": "This function returns the entire match."
    },
    {
        "QN": "210",
        "type": "mcq",
        "question": "What will be the output of the following Python code?\n\nsentence = 'we are humans'\nmatched = re.match(r'(.*) (.*?) (.*)', sentence)\nprint(matched.group(2))",
        "options": {
            "A": "'are'",
            "B": "'we'",
            "C": "'humans'",
            "D": "'we are humans'"
        },
        "answer": "A",
        "explanation": "This function returns the particular subgroup."
    },
    {
        "QN": "211",
        "type": "mcq",
        "question": "What will be the output of the following Python code?\n\nsentence = 'horses are fast'\nregex = re.compile('(?P<animal>\\w+) (?P<verb>\\w+) (?P<adjective>\\w+)')\nmatched = re.search(regex, sentence)\nprint(matched.groupdict())",
        "options": {
            "A": "{'animal': 'horses', 'verb': 'are', 'adjective': 'fast'}",
            "B": "('horses', 'are', 'fast')",
            "C": "'horses are fast'",
            "D": "'are'"
        },
        "answer": "A",
        "explanation": "This function returns a dictionary that contains all the matches."
    },
    {
        "QN": "212",
        "type": "mcq",
        "question": "What will be the output of the following Python code?\n\nsentence = 'horses are fast'\nregex = re.compile('(?P<animal>\\w+) (?P<verb>\\w+) (?P<adjective>\\w+)')\nmatched = re.search(regex, sentence)\nprint(matched.groups())",
        "options": {
            "A": "{'animal': 'horses', 'verb': 'are', 'adjective': 'fast'}",
            "B": "('horses', 'are', 'fast')",
            "C": "'horses are fast'",
            "D": "'are'"
        },
        "answer": "B",
        "explanation": "This function returns all the subgroups that have been matched."
    },
    {
        "QN": "213",
        "type": "mcq",
        "question": "What will be the output of the following Python code?\n\nsentence = 'horses are fast'\nregex = re.compile('(?P<animal>\\w+) (?P<verb>\\w+) (?P<adjective>\\w+)')\nmatched = re.search(regex, sentence)\nprint(matched.group(2))",
        "options": {
            "A": "{'animal': 'horses', 'verb': 'are', 'adjective': 'fast'}",
            "B": "('horses', 'are', 'fast')",
            "C": "'horses are fast'",
            "D": "'are'"
        },
        "answer": "D",
        "explanation": "This function returns the particular subgroup."
    },
    {
        "QN": "214",
        "type": "mcq",
        "question": "The character Dot (that is, \u2018.\u2019) in the default mode, matches any character other than _____________?",
        "options": {
            "A": "caret",
            "B": "ampersand",
            "C": "percentage symbol",
            "D": "newline"
        },
        "answer": "D",
        "explanation": "The character Dot (that is, \u2018,\u2019) in the default mode, matches any character other than newline. If DOTALL flag is used, then it matches any character other than newline."
    },
    {
        "QN": "215",
        "type": "mcq",
        "question": "The expression a{5} will match _____________ characters with the previous regular expression.",
        "options": {
            "A": "5 or less",
            "B": "exactly 5",
            "C": "5 or more",
            "D": "exactly 4"
        },
        "answer": "B",
        "explanation": "The character {m} is used to match exactly m characters to the previous regular expression. Hence the expression a{5} will match exactly 5 characters and not less than that."
    },
    {
        "QN": "216",
        "type": "mcq",
        "question": "________ matches the start of the string.\n________ matches the end of the string.",
        "options": {
            "A": "\u2018^\u2019, \u2018$\u2019",
            "B": "\u2018$\u2019, \u2018^\u2019",
            "C": "\u2018$\u2019, \u2018?\u2019",
            "D": "\u2018?\u2019, \u2018^\u2019"
        },
        "answer": "A",
        "explanation": "\u2018^\u2019 (carat) matches the start of the string.... \u2018$\u2019 (dollar sign) matches the end of the string."
    },
    {
        "QN": "217",
        "type": "mcq",
        "question": "Which of the following will result in an error?",
        "options": {
            "A": ">>> p = re.compile(\"d\") >>> p.search(\"door\")",
            "B": ">>> p = re.escape(\u2018hello\u2019)",
            "C": ">>> p = re.subn()",
            "D": ">>> p = re.purge()"
        },
        "answer": "C",
        "explanation": "The function re.subn() will result in an error. This is because subn() requires 3 positional arguments while we have entered none."
    },
    {
        "QN": "218",
        "type": "mcq",
        "question": "What will be the output of the following Python code?\nre.split('\\W+', 'Hello, hello, hello.')",
        "options": {
            "A": "[\u2018Hello\u2019, \u2018hello\u2019, \u2018hello.\u2019]",
            "B": "[\u2018Hello, \u2018hello\u2019, \u2018hello\u2019]",
            "C": "[\u2018Hello\u2019, \u2018hello\u2019, \u2018hello\u2019, \u2018.\u2019]",
            "D": "[\u2018Hello\u2019, \u2018hello\u2019, \u2018hello\u2019, \u201d]"
        },
        "answer": "D",
        "explanation": "In the code shown above, the function split() splits the string based on the pattern given as an argument in the parenthesis. Note: split will never split a string on an empty pattern match. Hence the output of this code is: [\u2018Hello\u2019, \u2018hello\u2019, \u2018hello\u2019, \u201d]."
    },
    {
        "QN": "219",
        "type": "mcq",
        "question": "What will be the output of the following Python function?... re.findall(\"hello world\", \"hello\", 1)",
        "options": {
            "A": "[\u201chello\u201d]",
            "B": "[ ]",
            "C": "hello",
            "D": "hello world"
        },
        "answer": "B",
        "explanation": "The function findall returns the word matched if and only if both the pattern and the string match completely, that is, they are exactly the same. Observe the example shown below:\n>>> re.findall(\u201chello\u201d, \u201chello\u201d, 1) The output is: [\u2018hello\u2019] Hence the output of the code shown in this question is []."
    },
    {
        "QN": "220",
        "type": "mcq",
        "question": "Choose the function whose output can be: <_sre.SRE_Match object; span=(4, 8), match=\u2019aaaa\u2019>.",
        "options": {
            "A": ">>> re.search(\u2018aaaa\u2019, \u201calohaaaa\u201d, 0)",
            "B": ">>> re.match(\u2018aaaa\u2019, \u201calohaaaa\u201d, 0)",
            "C": ">>> re.match(\u2018aaa\u2019, \u201calohaaa\u201d, 0)",
            "D": ">>> re.search(\u2018aaa\u2019, \u201calohaaa\u201d, 0)"
        },
        "answer": "A",
        "explanation": "The output shown above is that of a search function, whose pattern is \u2018aaaa\u2019 and the string is that of 8 characters. The only option which matches all these criteria is:\n>>> re.search(\u2018aaaa\u2019, \u201calohaaaa\u201d, 0)"
    },
    {
        "QN": "221",
        "type": "mcq",
        "question": "Which of the following functions clears the regular expression cache?",
        "options": {
            "A": "re.sub()",
            "B": "re.pos()",
            "C": "re.purge()",
            "D": "re.subn()"
        },
        "answer": "C",
        "explanation": "The function which clears the regular expression cache is re.purge(). Note that this function takes zero positional arguments."
    },
    {
        "QN": "222",
        "type": "mcq",
        "question": "What will be the output of the following Python code?\nimport re\nre.ASCII",
        "options": {
            "A": "8",
            "B": "32",
            "C": "64",
            "D": "256"
        },
        "answer": "D",
        "explanation": "The expression re.ASCII returns the total number of ASCII characters that are present, that is 256. This can also be abbreviated as re.A, which results in the same output (that is, 256)."
    },
    {
        "QN": "223",
        "type": "mcq",
        "question": "Which of the following functions results in case insensitive matching?",
        "options": {
            "A": "re.A",
            "B": "re.U",
            "C": "re.I",
            "D": "re.X"
        },
        "answer": "C",
        "explanation": "The function re.I (that is, re.IGNORECASE) results in case-insensitive matching. That is, expressions such as [A-Z] will match lowercase characters too."
    },
    {
        "QN": "224",
        "type": "mcq",
        "question": "What will be the output of the following Python code?\n\nre.compile('hello', re.X)",
        "options": {
            "A": "['h', 'e', 'l', 'l', 'o']",
            "B": "re.compile(\u2018hello\u2019, re.VERBOSE)",
            "C": "Error",
            "D": "Junk value"
        },
        "answer": "B",
        "explanation": "The compile function compiles a pattern of regular expression into an object of regular expression. Re.X is a flag which is also used as re.VERBOSE. Hence the output of this code is: re.compile(\u2018hello\u2019, re.VERBOSE)."
    },
    {
        "QN": "225",
        "type": "mcq",
        "question": "What will be the output of the following Python code?\n\nre.split('[a-c]', '0a3B6', re.I)",
        "options": {
            "A": "Error",
            "B": "[\u2018a\u2019, \u2018B\u2019]",
            "C": "[\u20180\u2019, \u20183B6\u2019]",
            "D": "[\u2018a\u2019]"
        },
        "answer": "C",
        "explanation": "The function re.split() splits the string on the basis of the pattern given in the parenthesis. Since we have used the flag e.I (that is, re.IGNORECASE), the output is: [\u20180\u2019, \u20183B6\u2019]."
    },
    {
        "QN": "226",
        "type": "mcq",
        "question": "What will be the output of the following Python code?\n\nre.sub('morning', 'evening', 'good morning')",
        "options": {
            "A": "\u2018good evening\u2019",
            "B": "\u2018good\u2019",
            "C": "\u2018morning\u2019",
            "D": "\u2018evening\u2019"
        },
        "answer": "A",
        "explanation": "The code shown above first searches for the pattern \u2018morning\u2019 in the string \u2018good morning\u2019 and then replaces this pattern with \u2018evening\u2019. Hence the output of this code is: \u2018good evening\u2019."
    },
    {
        "QN": "227",
        "type": "mcq",
        "question": "The function re.error raises an exception if a particular string contains no match for the given pattern.",
        "options": {
            "A": "True",
            "B": "False"
        },
        "answer": "B",
        "explanation": "The function re.error raises an exception when a string passed to one of its functions here is not a valid regular expression. It does not raise an exception if a particular string does not contain a match for the given pattern."
    },
    {
        "QN": "228",
        "type": "mcq",
        "question": "What will be the output of the following Python code?\n\nre.escape('new**world')",
        "options": {
            "A": "\u2018new world\u2019",
            "B": "\u2018new\\\\*\\\\*world\u2019",
            "C": "\u2018**\u2019",
            "D": "\u2018new\u2019, \u2018*\u2019, \u2018*\u2019, \u2018world\u2019"
        },
        "answer": "B",
        "explanation": "The function re.escape escapes all the characters in the pattern other than ASCII letters and numbers. Hence the output of the code shown above is: \u2018new\\\\*\\\\*world\u2019."
    },
    {
        "QN": "229",
        "type": "mcq",
        "question": "What will be the output of the following Python code?\n\nre.fullmatch('hello', 'hello world')",
        "options": {
            "A": "No output",
            "B": "[]",
            "C": "<_sre.SRE_Match object; span=(0, 5), match='hello'>",
            "D": "Error"
        },
        "answer": "A",
        "explanation": "The function re.fullmatch applies the pattern to the entire string and returns an object if match is found and none if match in not found. In the code shown above, match is not found. Hence there is no output."
    },
    {
        "QN": "230",
        "type": "mcq",
        "question": "Choose the option wherein the two choices do not refer to the same option.",
        "options": {
            "A": "re.I   re.IGNORECASE",
            "B": "re.M   re.MULTILINE",
            "C": "re.X   re.VERBOSE",
            "D": "re.L   re.LOWERCASE"
        },
        "answer": "D",
        "explanation": "The function re.L is also written as re.LOCALE. There is no function such as re.LOWERCASE in the re module of Python."
    },
    {
        "QN": "231",
        "type": "mcq",
        "question": "The difference between the functions re.sub and re.subn is that re.sub returns a _______________ whereas re.subn returns a __________________",
        "options": {
            "A": "string, list",
            "B": "list, tuple",
            "C": "string, tuple",
            "D": "tuple, list"
        },
        "answer": "C",
        "explanation": "The difference the functions re.sub and re.subn is that re.sub returns a string whereas re.subn returns a tuple."
    },
    {
        "QN": "232",
        "type": "mcq",
        "question": "What will be the output of the following Python code?\n\nre.split('mum', 'mumbai*', 1)",
        "options": {
            "A": "Error",
            "B": "[\u201d, \u2018bai*\u2019]",
            "C": "[\u201d, \u2018bai\u2019]",
            "D": "[\u2018bai*\u2019]"
        },
        "answer": "B",
        "explanation": "The code shown above splits the string based on the pattern given as an argument. Hence the output of the code is: [\u201d, \u2018bai*\u2019]."
    },
    {
        "QN": "233",
        "type": "mcq",
        "question": "What will be the output of the following Python code?\n\nre.findall('good', 'good is good') re.findall('good', 'bad is good')",
        "options": {
            "A": "[\u2018good\u2019, \u2018good\u2019] [\u2018good\u2019]",
            "B": "(\u2018good\u2019, \u2018good\u2019) (good)",
            "C": "(\u2018good\u2019) (\u2018good\u2019)",
            "D": "[\u2018good\u2019] [\u2018good\u2019]"
        },
        "answer": "A",
        "explanation": "The function findall returns a list of all the non overlapping matches in a string. Hence the output of the first function is: [\u2018good\u2019, \u2018good\u2019] and that of the second function is: [\u2018good\u2019]."
    },
    {
        "QN": "234",
        "type": "mcq",
        "question": "What will be the output of the following Python code?\n\nre.split(r'(n\\d)=', 'n1=3.1, n2=5, n3=4.565')",
        "options": {
            "A": "Error",
            "B": "[\u201d, \u2018n1\u2019, \u20183.1, \u2018, \u2018n2\u2019, \u20185, \u2018, \u2018n3\u2019, \u20184.565\u2019]",
            "C": "[\u2018n1\u2019, \u20183.1, \u2018, \u2018n2\u2019, \u20185, \u2018, \u2018n3\u2019, \u20184.565\u2019]",
            "D": "[\u20183.1, \u2018, \u20185, \u2018, \u20184.565\u2019]"
        },
        "answer": "B",
        "explanation": "In the snippet of code shown above, we extract the numbers as a list of floating point values, including the initial empty string. The example shown above demonstrate how groups in the regular expression influence the result of re.split. Hence the output of the code shown above is:\n\n[\u201d, \u2018n1\u2019, \u20183.1, \u2018, \u2018n2\u2019, \u20185, \u2018, \u2018n3\u2019, \u20184.565\u2019]."
    },
    {
        "QN": "235",
        "type": "mcq",
        "question": "The function of re.search is __________",
        "options": {
            "A": "Matches a pattern at the start of the string",
            "B": "Matches a pattern at the end of the string",
            "C": "Matches a pattern from any part of a string",
            "D": "Such a function does not exist"
        },
        "answer": "C",
        "explanation": "The re module of Python consists of a function re.search. It\u2019s function is to match a pattern from anywhere in a string."
    },
    {
        "QN": "236",
        "type": "mcq",
        "question": "Which of the following functions creates a Python object?",
        "options": {
            "A": "re.compile(str)",
            "B": "re.assemble(str)",
            "C": "re.regex(str)",
            "D": "re.create(str)"
        },
        "answer": "A",
        "explanation": "The function re.compile(srt) compiles a pattern of regular expression into an object of regular expression. Hence re.compile(str) is the only function from the above options which creates an object."
    },
    {
        "QN": "237",
        "type": "mcq",
        "question": "Which of the following pattern matching modifiers permits whitespace and comments inside the regular expression?",
        "options": {
            "A": "re.L",
            "B": "re.S",
            "C": "re.U",
            "D": "re.X"
        },
        "answer": "D",
        "explanation": "The modifier re.X allows whitespace and comments inside the regular expressions."
    },
    {
        "QN": "238",
        "type": "mcq",
        "question": "What will be the output of the following Python code?\n\ns = 'welcome home' m = re.match(r'(.*)(.*?)', s) print(m.group())",
        "options": {
            "A": "(\u2018welcome\u2019, \u2018home\u2019)",
            "B": "[\u2018welcome\u2019, \u2018home\u2019]",
            "C": "welcome home",
            "D": "[\u2018welcome\u2019 // \u2018home\u2019 ]"
        },
        "answer": "C",
        "explanation": "The code shown above shows the function re.match combined with the use of special characters. Hence the output of this code is: welcome home."
    },
    {
        "QN": "239",
        "type": "mcq",
        "question": "The function of re.match is ____________",
        "options": {
            "A": "Error",
            "B": "Matches a pattern anywhere in the string",
            "C": "Matches a pattern at the end of the string",
            "D": "Matches a pattern at the start of the string"
        },
        "answer": "D",
        "explanation": "The function of re.match matches a pattern at the start of the string."
    },
    {
        "QN": "240",
        "type": "mcq",
        "question": "The special character \\B matches the empty string, but only when it is _____________",
        "options": {
            "A": "at the beginning or end of a word",
            "B": "not at the beginning or end of a word",
            "C": "at the beginning of the word",
            "D": "at the end of the word"
        },
        "answer": "B",
        "explanation": "The special character \\B matches the empty string, but only when it is not at the beginning or end of a word."
    },
    {
        "QN": "241",
        "type": "mcq",
        "question": "What will be the output of the following Python code?\n\nimport re s = \"A new day\" m = re.match(r'(.*)(.*?)', s) print(m.group(2)) print(m.group(0))",
        "options": {
            "A": "No output\nA new day",
            "B": "No output\nNo output",
            "C": "[\u2018A\u2019, \u2018new\u2019, \u2018day\u2019]\n(\u2018A\u2019, \u2018new\u2019, \u2018day\u2019)",
            "D": "Error\n[\u2018A\u2019, \u2018new\u2019, \u2018day\u2019]"
        },
        "answer": "A",
        "explanation": "The code shown above demonstrates the use of the function re.match, with different arguments given to the group method. Hence the first function does not return any output whereas the second function returns the output: A new day"
    },
    {
        "QN": "242",
        "type": "mcq",
        "question": "Which of the following special characters matches a pattern only at the end of the string?",
        "options": {
            "A": "\\B",
            "B": "\\X",
            "C": "\\Z",
            "D": "\\A"
        },
        "answer": "C",
        "explanation": "\\B matches a pattern which is not at the beginning or end of a string. \\X refers to re.VERBOSE. \\A matches a pattern only at the start of a string. \\Z matches a pattern only at the end of a string."
    },
    {
        "QN": "243",
        "type": "mcq",
        "question": "The output of the following two Python codes are the same.\n\np = re.compile('hello') r = p.match('hello everyone') print(r.group(0))\nr = re.match('hello', 'hello everyone') print(r.group(0))",
        "options": {
            "A": "True",
            "B": "False"
        },
        "answer": "A",
        "explanation": "The two codes shown above are equivalent. Both of these codes result in the same output, that is: hello. Hence this statement is true."
    },
    {
        "QN": "244",
        "type": "mcq",
        "question": "What will be the output of the following Python code?\n\nre.match('sp(.*)am', 'spam')",
        "options": {
            "A": "<_sre.SRE_Match object; span=(1, 4), match=\u2019spam\u2019>",
            "B": "<_sre.SRE_Match object; span=(0, 4), match=\u2019spam\u2019>",
            "C": "No output",
            "D": "Error"
        },
        "answer": "B",
        "explanation": "The code shown above demonstrates the function re.match, combined with a special character. The output of the code shown is: <_sre.SRE_Match object; span=(0, 4), match=\u2019spam\u2019>"
    },
    {
        "QN": "245",
        "type": "mcq",
        "question": "Which of the following special characters represents a comment (that is, the contents of the parenthesis are simply ignores)?",
        "options": {
            "A": "(?:\u2026)",
            "B": "(?=\u2026)",
            "C": "(?!\u2026)",
            "D": "(?#\u2026)"
        },
        "answer": "D",
        "explanation": "The special character (?#\u2026) represent a comment, that is, the contents of the parenthesis are simply ignored."
    },
    {
        "QN": "246",
        "type": "mcq",
        "question": "Which of the codes shown below results in a match?",
        "options": {
            "A": "re.match(\u2018George(?=Washington)\u2019, \u2018George Washington\u2019)",
            "B": "re.match(\u2018George(?=Washington)\u2019, \u2018George\u2019)",
            "C": "re.match(\u2018George(?=Washington)\u2019, \u2018GeorgeWashington\u2019)",
            "D": "re.match(\u2018George(?=Washington)\u2019, \u2018Georgewashington\u2019)"
        },
        "answer": "C",
        "explanation": "The code shown above demonstrates the use of the function re.match, along with the special character ?=. This results in a match only when \u2018George\u2019 is immediately followed by \u2018Washington\u2019. Also, we have not used the module to ignore case. Hence the match is case-sensitive. Therefore the only option which results in a match is:\n\nre.match(\u2018George(?=Washington)\u2019, \u2018GeorgeWashington\u2019)"
    },
    {
        "QN": "247",
        "type": "mcq",
        "question": "What will be the output of the following Python code?\n\nre.split(r'(a)(t)', 'Maths is a difficult subject')",
        "options": {
            "A": "[\u2018M a t h s i s a d i f f i c u l t s u b j e c t\u2019]",
            "B": "[\u2018Maths\u2019, \u2018is\u2019, \u2018a\u2019, \u2018difficult\u2019, \u2018subject\u2019]",
            "C": "\u2018Maths is a difficult subject\u2019",
            "D": "[\u2018M\u2019, \u2018a\u2019, \u2018t\u2019, \u2018hs is a difficult subject\u2019]"
        },
        "answer": "D",
        "explanation": "The code demonstrates the use of the function re.match. The first argument specifies the pattern. Since the pattern contains groups, those groups are incorporated in the resultant list as well. Hence the output is [\u2018M\u2019, \u2018a\u2019, \u2018t\u2019, \u2018hs is a difficult subject\u2019]."
    },
    {
        "QN": "248",
        "type": "mcq",
        "question": "The output of the following two Python codes are the same.\n\nCODE 1 >>> re.split(r'(a)(t)', 'The night sky') CODE 2 >>> re.split(r'\\s+', 'The night sky')",
        "options": {
            "A": "True",
            "B": "False",
            "C": " ",
            "D": " "
        },
        "answer": "B",
        "explanation": "The output of the first code is: [\u2018The night sky\u2019] whereas the output of the second code is:[\u2018The\u2019, \u2018night\u2019, \u2018sky\u2019]. Clearly, the outputs of the two codes are different. Hence the statement given above is a false one."
    },
    {
        "QN": "249",
        "type": "mcq",
        "question": "What will be the output of the following Python code?\n\nimport re s = 'abc123 xyz666 lmn-11 def77' re.sub(r'\\b([a-z]+)(\\d+)', r'\\2\\1:', s)",
        "options": {
            "A": "\u2018123abc: 666xyz: lmn-11 77def:\u2019",
            "B": "\u201877def: lmn-11: 666xyz: 123abc\u2019",
            "C": "\u2018abc123:\u2019, \u2018xyz666:\u2019, \u2018lmn-11:\u2019, \u2018def77:\u2019",
            "D": "\u2018abc123: xyz666: lmn-11: def77\u2019"
        },
        "answer": "A",
        "explanation": "The function re.sub returns a string produced by replacing every non overlapping occurrence of the first argument with the second argument in the third argument. Hence the output is: \u2018123abc: 666xyz: lmn-11 77def:\u2019"
    },
    {
        "QN": "250",
        "type": "mcq",
        "question": "What will be the output of the following Python code?\n\nre.subn('A', 'X', 'AAAAAA', count=4)",
        "options": {
            "A": "\u2018XXXXAA, 4\u2019",
            "B": "\u2018AAAAAA\u2019, 4",
            "C": "(\u2018XXXXAA\u2019, 4)",
            "D": "\u2018AAAAAA, 4\u2019"
        },
        "answer": "C",
        "explanation": "The line of code shown above demonstrates the function re.subn. This function is very similar to the function re.sub except that in the former, a tuple is returned instead of a string. The output of the code shown above is: (\u2018XXXXAA\u2019, 4)."
    },
    {
        "QN": "251",
        "type": "mcq",
        "question": "What will be the output of the following Python code?\n\nn = re.sub(r'\\w+', 'Hello', 'Cats and dogs')",
        "options": {
            "A": "Hello Hello Hello",
            "B": "\u2018Hello Hello Hello\u2019",
            "C": "[\u2018Hello\u2019, \u2018Hello\u2019, \u2018Hello\u2019]",
            "D": "(\u2018Hello\u2019, \u2018Hello\u2019, \u2018Hello\u2019)"
        },
        "answer": "B",
        "explanation": "The code shown above demonstrates the function re.sub. Since the string given as an argument consists of three words. The output of the code is: \u2018Hello Hello Hello\u2019. Had the string consisted of 4 words, the output would be: \u2018Hello Hello Hello Hello\u2019"
    },
    {
        "QN": "252",
        "type": "mcq",
        "question": "What will be the output of the following Python code?\n\nw = re.compile('[A-Za-z]+') w.findall('It will rain today')",
        "options": {
            "A": "\u2018It will rain today\u2019",
            "B": "(\u2018It will rain today\u2019)",
            "C": "[\u2018It will rain today\u2019]",
            "D": "[\u2018It\u2019, \u2018will\u2019, \u2018rain\u2019, \u2018today\u2019]"
        },
        "answer": "D",
        "explanation": "The code shown above demonstrates the function re.findall. Since all the words in the string match the criteria, the output of the code is: [\u2018It\u2019, \u2018will\u2019, \u2018rain\u2019, \u2018today\u2019]."
    },
    {
        "QN": "253",
        "type": "mcq",
        "question": "In the functions re.search.start(group) and re.search.end(group), if the argument groups not specified, it defaults to __________",
        "options": {
            "A": "Zero",
            "B": "None",
            "C": "One",
            "D": "Error"
        },
        "answer": "A",
        "explanation": "In the functions re.search.start(group) and re.search.end(group), if the argument groups not specified, it defaults to Zero."
    },
    {
        "QN": "254",
        "type": "mcq",
        "question": "What will be the output of the following Python code?\n\nre.split(r'\\s+', 'Chrome is better than explorer', maxspilt=3)",
        "options": {
            "A": "[\u2018Chrome\u2019, \u2018is\u2019, \u2018better\u2019, \u2018than\u2019, \u2018explorer\u2019]",
            "B": "[\u2018Chrome\u2019, \u2018is\u2019, \u2018better\u2019, \u2018than explorer\u2019]",
            "C": "(\u2018Chrome\u2019, \u2018is\u2019, \u2018better\u2019, \u2018than explorer\u2019)",
            "D": "\u2018Chrome is better\u2019 \u2018than explorer\u2019"
        },
        "answer": "B",
        "explanation": "The code demonstrates the use of the function re.split, including the use of maxsplit. Since maxsplit is equal to 3, the output of the code is:[\u2018Chrome\u2019, \u2018is\u2019, \u2018better\u2019, \u2018than explorer\u2019]"
    },
    {
        "QN": "255",
        "type": "mcq",
        "question": "What will be the output of the following Python code?\n\na=re.compile('[0-9]+') a.findall('7 apples and 3 mangoes')",
        "options": {
            "A": "[\u2018apples\u2019 \u2018and\u2019 \u2018mangoes\u2019]",
            "B": "(7, 3)",
            "C": "[\u20187\u2019, \u20183\u2019]",
            "D": "Error"
        },
        "answer": "C",
        "explanation": "The code demonstrates the use of the functions re.compile and re.findall. Since we have specified in the code that only digits from 0-9 be found, hence the output of this code is: [\u20187\u2019, \u20183\u2019]."
    },
    {
        "QN": "256",
        "type": "mcq",
        "question": "Which of the following functions returns a dictionary mapping group names to group numbers?",
        "options": {
            "A": "re.compile.group",
            "B": "re.compile.groupindex",
            "C": "re.compile.index",
            "D": "re.compile.indexgroup"
        },
        "answer": "B",
        "explanation": "The function re.compile.groupindex returns a dictionary mapping group names to group numbers."
    },
    {
        "QN": "257",
        "type": "mcq",
        "question": "Which of the following statements regarding the output of the function re.match is incorrect?",
        "options": {
            "A": "\u2018pq*\u2019 will match \u2018pq\u2019",
            "B": "\u2018pq?\u2019 matches \u2018p\u2019",
            "C": "\u2018p{4}, q\u2019 does not match \u2018pppq\u2019",
            "D": "\u2018pq+\u2019 matches \u2018p\u2019"
        },
        "answer": "D",
        "explanation": "All of the above statements are correct except that \u2018pq+\u2019 match \u2018p\u2019. \u2018pq+\u2019 will match \u2018p\u2019 followed by any non-zero number of q\u2019s, but it will not match \u2018p\u2019."
    },
    {
        "QN": "258",
        "type": "mcq",
        "question": "The following Python code snippet results in an error.\nc=re.compile(r'(\\d+)([A-Z]+)([a-z]+)')\nc.groupindex",
        "options": {
            "A": "True",
            "B": "False",
            "C": "None",
            "D": "Error"
        },
        "answer": "B",
        "explanation": "In the code shown above, none of the group names match the group numbers. In such a case, no error is thrown. The output of the code is an empty dictionary, that is, {}."
    },
    {
        "QN": "259",
        "type": "mcq",
        "question": "Which of the following functions does not accept any argument?",
        "options": {
            "A": "re.purge",
            "B": "re.compile",
            "C": "re.findall",
            "D": "re.match"
        },
        "answer": "A",
        "explanation": "The function re.purge is used to clear the cache and it does not accept any arguments."
    },
    {
        "QN": "260",
        "type": "mcq",
        "question": "What will be the output of the following Python code?\na = re.compile('0-9')\na.findall('3 trees')",
        "options": {
            "A": "[]",
            "B": "['3']",
            "C": "Error",
            "D": "['trees']"
        },
        "answer": "A",
        "explanation": "The output of the code shown above is an empty list. This is due to the way the arguments have been passed to the function re.compile. Carefully read the code shown below in order to understand the correct syntax:\n>>> a = re.compile(\u2018[0-9]\u2019)\n>>> a.findall(\u20183 trees\u2019)\n[\u20183\u2019]."
    },
    {
        "QN": "261",
        "type": "mcq",
        "question": "Which of the following lines of code will not show a match?",
        "options": {
            "A": ">>> re.match(\u2018ab*\u2019, \u2018a\u2019)",
            "B": ">>> re.match(\u2018ab*\u2019, \u2018ab\u2019)",
            "C": ">>> re.match(\u2018ab*\u2019, \u2018abb\u2019)",
            "D": ">>> re.match(\u2018ab*\u2019, \u2018ba\u2019)"
        },
        "answer": "D",
        "explanation": "In the code shown above, ab* will match to \u2018a\u2019 or \u2018ab\u2019 or \u2018a\u2019 followed by any number of b\u2019s. Hence the only line of code from the above options which does not result in a match is:\n>>> re.match(\u2018ab*\u2019, \u2018ba\u2019)."
    },
    {
        "QN": "262",
        "type": "mcq",
        "question": "What will be the output of the following Python code?\nm = re.search('a', 'The blue umbrella')\nm.re.pattern",
        "options": {
            "A": "{}",
            "B": "\u2018The blue umbrella\u2019",
            "C": "\u2018a\u2019",
            "D": "No output"
        },
        "answer": "C",
        "explanation": "The PatternObject is used to produce the match. The real regular expression pattern string must be retrieved from the PatternObject\u2019s pattern method. Hence the output of this code is: \u2018a\u2019."
    },
    {
        "QN": "263",
        "type": "mcq",
        "question": "What will be the output of the following Python code?\nre.sub('Y', 'X', 'AAAAAA', count=2)",
        "options": {
            "A": "\u2018YXAAAA\u2019",
            "B": "(\u2018YXAAAA\u2019)",
            "C": "(\u2018AAAAAA\u2019)",
            "D": "\u2018AAAAAA\u2019"
        },
        "answer": "D",
        "explanation": "The code shown above demonstrates the function re.sub, which returns a string. The pattern specified is substituted in the string and returned. Hence the output of the code shown above is: \u2018AAAAAA\u2019."
    }
]